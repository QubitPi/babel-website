"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["2582"],{64165:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},default:function(){return p},toc:function(){return h},metadata:function(){return r},assets:function(){return a},contentTitle:function(){return c}});var r=JSON.parse('{"id":"babel-generator","title":"@babel/generator","description":"Turns Babel AST into code.","source":"@site/../docs/generator.md","sourceDirName":".","slug":"/babel-generator","permalink":"/docs/babel-generator","draft":false,"unlisted":false,"editUrl":"https://github.com/babel/website/edit/main/docs/../docs/generator.md","tags":[],"version":"current","frontMatter":{"id":"babel-generator","title":"@babel/generator"},"sidebar":"docs","previous":{"title":"@babel/core","permalink":"/docs/babel-core"},"next":{"title":"@babel/compat-data","permalink":"/docs/babel-compat-data"}}'),s=t(24246),i=t(80980),l=t(95181),d=t(38049);let o={id:"babel-generator",title:"@babel/generator"},c=void 0,a={},h=[{value:"Install",id:"install",level:2},{value:"Usage",id:"usage",level:2},{value:"Parser plugins support",id:"parser-plugins-support",level:3},{value:"API",id:"api",level:2},{value:"Options",id:"options",level:3},{value:"Result",id:"result",level:3},{value:"AST from Multiple Sources",id:"ast-from-multiple-sources",level:2}];function u(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components},{Details:t}=n;return t||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Turns Babel AST into code."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"install",children:"Install"}),"\n",(0,s.jsxs)(l.Z,{groupId:"npm2yarn",children:[(0,s.jsx)(d.Z,{value:"npm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm install --save-dev @babel/generator\n"})})}),(0,s.jsx)(d.Z,{value:"yarn",label:"Yarn",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"yarn add --dev @babel/generator\n"})})}),(0,s.jsx)(d.Z,{value:"pnpm",label:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"pnpm add --save-dev @babel/generator\n"})})}),(0,s.jsx)(d.Z,{value:"bun",label:"Bun",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"bun add --dev @babel/generator\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="JavaScript"',children:'import { parse } from "@babel/parser";\nimport { generate } from "@babel/generator";\n\nconst code = "class Example {}";\nconst ast = parse(code);\n\nconst output = generate(\n  ast,\n  {\n    /* options */\n  },\n  code\n);\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"The symbols like white spaces or new line characters are not preserved in the AST. When Babel generator prints code from the AST, the output format is not guaranteed."})}),"\n",(0,s.jsx)(n.h3,{id:"parser-plugins-support",children:"Parser plugins support"}),"\n",(0,s.jsxs)(n.p,{children:["Babel generator supports all the listed ",(0,s.jsx)(n.a,{href:"/docs/babel-parser#plugins",children:"Babel parser plugins"})," except ",(0,s.jsx)(n.code,{children:"estree"}),". Note that parser plugins do not transform the code. For example,\nif you pass JSX ",(0,s.jsx)(n.code,{children:"<div></div>"})," to babel generator, the result will still contain the ",(0,s.jsx)(n.code,{children:"div"})," JSX element."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="JavaScript"',children:'import { parse } from "@babel/parser";\nimport { generate } from "@babel/generator";\n\nconst code = "const Example = () => <div>example</div>";\nconst ast = parse(code, { plugins: ["jsx" ] });\n\nconst output = generate(\n  ast,\n).code;\n\n// true\noutput.includes("<div>");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,s.jsxs)(n.p,{children:["Babel generator contains exactly one function ",(0,s.jsx)(n.code,{children:"generate"}),". It can be imported in different ways."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="JavaScript"',children:'const generate = require("@babel/generator");\nconst { generate } = require("@babel/generator");\nimport { generate } from "@babel/generator";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"History"}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Version"}),(0,s.jsx)(n.th,{children:"Changes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"v7.26.0"}),(0,s.jsxs)(n.td,{children:["Added ",(0,s.jsx)(n.code,{children:"experimental_preserveFormat"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"v7.22.0"}),(0,s.jsxs)(n.td,{children:["Added ",(0,s.jsx)(n.code,{children:"importAttributesKeyword"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"v7.21.0"}),(0,s.jsxs)(n.td,{children:["Added ",(0,s.jsx)(n.code,{children:"inputSourceMap"})]})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Options for formatting output:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"type"}),(0,s.jsx)(n.th,{children:"default"}),(0,s.jsx)(n.th,{children:"description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"auxiliaryCommentAfter"}),(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Optional string to add as a block comment at the end of the output file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"auxiliaryCommentBefore"}),(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Optional string to add as a block comment at the start of the output file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"comments"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Should comments be included in output"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"compact"}),(0,s.jsxs)(n.td,{children:["boolean or ",(0,s.jsx)(n.code,{children:"'auto'"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"opts.minified"})}),(0,s.jsxs)(n.td,{children:["Set to ",(0,s.jsx)(n.code,{children:"true"})," to avoid adding whitespace for formatting"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"concise"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsxs)(n.td,{children:["Set to ",(0,s.jsx)(n.code,{children:"true"})," to reduce whitespace (but not as much as ",(0,s.jsx)(n.code,{children:"opts.compact"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"decoratorsBeforeExport"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:["Set to ",(0,s.jsx)(n.code,{children:"true"})," to print decorators before ",(0,s.jsx)(n.code,{children:"export"})," in output."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"filename"}),(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"Used in warning messages"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"importAttributesKeyword"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:'"with"'}),", ",(0,s.jsx)(n.code,{children:'"assert"'}),", or ",(0,s.jsx)(n.code,{children:'"with-legacy"'})]}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:["The import attributes/assertions syntax to use. ",(0,s.jsx)(n.code,{children:'"with"'})," for ",(0,s.jsx)(n.code,{children:'import "..." with { type: "json" }'}),", ",(0,s.jsx)(n.code,{children:'"assert"'})," for ",(0,s.jsx)(n.code,{children:'import "..." assert { type: "json" }'}),", and ",(0,s.jsx)(n.code,{children:'"with-legacy"'})," for ",(0,s.jsx)(n.code,{children:'import "..." with type: "json"'}),". When not specified, ",(0,s.jsx)(n.code,{children:"@babel/generator"})," will try to match the style in the input code based on the AST shape."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"jsescOption"}),(0,s.jsx)(n.td,{children:"object"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:["Use ",(0,s.jsx)(n.code,{children:"jsesc"})," to process literals. ",(0,s.jsx)(n.code,{children:"jsesc"})," is applied to numbers only if ",(0,s.jsx)(n.code,{children:"jsescOption.numbers"})," (added in ",(0,s.jsx)(n.code,{children:"v7.9.0"}),") is present. You can customize ",(0,s.jsx)(n.code,{children:"jsesc"})," by ",(0,s.jsx)(n.a,{href:"https://github.com/mathiasbynens/jsesc#api",children:"passing options"})," to it."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"jsonCompatibleStrings"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsxs)(n.td,{children:["Set to true to run ",(0,s.jsx)(n.code,{children:"jsesc"}),' with "json": true to print "\\u00A9" vs. "\xa9";']})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"minified"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Should the output be minified"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"retainFunctionParens"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Retain parens around function expressions (could be used to change engine parsing behavior)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"retainLines"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"shouldPrintComment"}),(0,s.jsx)(n.td,{children:"function"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"opts.comments"})}),(0,s.jsxs)(n.td,{children:["Function that takes a comment (as a string) and returns ",(0,s.jsx)(n.code,{children:"true"})," if the comment should be included in the output. By default, comments are included if ",(0,s.jsx)(n.code,{children:"opts.comments"})," is ",(0,s.jsx)(n.code,{children:"true"})," or if ",(0,s.jsx)(n.code,{children:"opts.minified"})," is ",(0,s.jsx)(n.code,{children:"false"})," and the comment contains ",(0,s.jsx)(n.code,{children:"@preserve"})," or ",(0,s.jsx)(n.code,{children:"@license"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"recordAndTupleSyntaxType"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"'hash'"})," or ",(0,s.jsx)(n.code,{children:"'bar'"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'hash'"})}),(0,s.jsx)(n.td,{children:"For use with the recordAndTuple token."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"topicToken"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"'%'"})," or ",(0,s.jsx)(n.code,{children:"'#'"})]}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:["The token to use with ",(0,s.jsx)(n.a,{href:"/docs/babel-plugin-proposal-pipeline-operator",children:"Hack-pipe topic references"}),". This is required when there are any ",(0,s.jsx)(n.code,{children:"TopicReference"})," nodes."]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Options for source maps:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"type"}),(0,s.jsx)(n.th,{children:"default"}),(0,s.jsx)(n.th,{children:"description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sourceMaps"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Enable generating source maps"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"inputSourceMap"}),(0,s.jsx)(n.td,{children:"string or object"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"The input source map"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sourceRoot"}),(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"A root for all relative URLs in the source map"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sourceFileName"}),(0,s.jsx)(n.td,{children:"string"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:["The filename for the source code (i.e. the code in the ",(0,s.jsx)(n.code,{children:"code"})," argument). This will only be used if ",(0,s.jsx)(n.code,{children:"code"})," is a string."]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Experimental options:"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The behavior of experimental options could have breaking changes in ",(0,s.jsx)(n.em,{children:"minor"})," versions."]})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"type"}),(0,s.jsx)(n.th,{children:"default"}),(0,s.jsx)(n.th,{children:"description"}),(0,s.jsx)(n.th,{children:"experimental reason"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"experimental_preserveFormat"}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsxs)(n.td,{children:["When set to ",(0,s.jsx)(n.code,{children:"true"}),", the generator will try to preserve location of all the nodes and tokens that are present both in the input and output code. To use this option, you currently need to enable the ",(0,s.jsx)(n.code,{children:"retainLines: true"})," generator option, and the ",(0,s.jsx)(n.code,{children:"tokens: true"})," and ",(0,s.jsx)(n.code,{children:"createParenthesizedExpressions: true"})," parser options."]}),(0,s.jsx)(n.td,{children:"This option will graduate to stable once it supports a mode that does not require preserving line numbers, but just relative positions of tokens."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"result",children:"Result"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"generate"})," API returns an object containing the source code and the source map information when the ",(0,s.jsx)(n.code,{children:"sourceMaps"})," option is enabled. Its fields are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"code: string"})," - The output source code from the provided AST"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"map: EncodedSourceMap | null"})," - The output source map in ",(0,s.jsx)(n.a,{href:"https://github.com/jridgewell/gen-mapping/blob/75eff9d01ef5da5477e316ec0f4f917ebe08dd96/src/types.ts#L13",children:"encoded form"}),". It is lazily-evaluated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"decodedMap: DecodedSourceMap | undefined"})," - The output source map in ",(0,s.jsx)(n.a,{href:"https://github.com/jridgewell/gen-mapping/blob/75eff9d01ef5da5477e316ec0f4f917ebe08dd96/src/types.ts#L17",children:"decoded form"}),". It is lazily-evaluated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rawMappings: Mapping[]"})," - A high-level ",(0,s.jsx)(n.a,{href:"https://github.com/jridgewell/gen-mapping/blob/75eff9d01ef5da5477e316ec0f4f917ebe08dd96/src/types.ts#L26",children:"mapping object"})," for every recorded segments in order to generate the source map. It is lazily-evaluated"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ast-from-multiple-sources",children:"AST from Multiple Sources"}),"\n",(0,s.jsxs)(n.p,{children:["In most cases, Babel does a 1:1 transformation of input-file to output-file. However,\nyou may be dealing with AST constructed from multiple sources - JS files, templates, etc.\nIf this is the case, and you want the sourcemaps to reflect the correct sources, you'll need\nto pass an object to ",(0,s.jsx)(n.code,{children:"generate"})," as the ",(0,s.jsx)(n.code,{children:"code"})," parameter. Keys\nshould be the source filenames, and values should be the source content."]}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of what that might look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="JavaScript"',children:'import { parse } from "@babel/parser";\nimport { generate } from "@babel/generator";\n\nconst a = "var a = 1;";\nconst b = "var b = 2;";\nconst astA = parse(a, { sourceFilename: "a.js" });\nconst astB = parse(b, { sourceFilename: "b.js" });\nconst ast = {\n  type: "Program",\n  body: [].concat(astA.program.body, astB.program.body),\n};\n\nconst { code, map } = generate(\n  ast,\n  { sourceMaps: true },\n  {\n    "a.js": a,\n    "b.js": b,\n  }\n);\n\n// Sourcemap will point to both a.js and b.js where appropriate.\n'})})]})}function p(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},38049:function(e,n,t){t.d(n,{Z:function(){return i}});var r=t(24246);t(27378);var s=t(90496);function i(e){let{children:n,hidden:t,className:i}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.Z)("tabItem_wHwb",i),hidden:t,children:n})}},95181:function(e,n,t){t.d(n,{Z:function(){return f}});var r=t(24246),s=t(27378),i=t(90496),l=t(85403),d=t(3620),o=t(77090),c=t(76180),a=t(23418),h=t(19073);function u(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var j=t(3344);function x(e){let{className:n,block:t,selectedValue:s,selectValue:d,tabValues:o}=e,c=[],{blockElementScrollPositionUntilNextRender:a}=(0,l.o5)(),h=e=>{let n=e.currentTarget,t=o[c.indexOf(n)].value;t!==s&&(a(n),d(t))},u=e=>{let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{let t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1]}}n?.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n),children:o.map(e=>{let{value:n,label:t,attributes:l}=e;return(0,r.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>{c.push(e)},onKeyDown:u,onClick:h,...l,className:(0,i.Z)("tabs__item","tabItem_l0OV",l?.className,{"tabs__item--active":s===n}),children:t??n},n)})})}function m(e){let{lazy:n,children:t,selectedValue:l}=e,d=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=d.find(e=>e.props.value===l);return e?(0,s.cloneElement)(e,{className:(0,i.Z)("margin-top--md",e.props.className)}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:d.map((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==l}))})}function b(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:r}=e,i=function(e){let{values:n,children:t}=e;return(0,s.useMemo)(()=>{let e=n??u(t).map(e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}),r=(0,a.lx)(e,(e,n)=>e.value===n.value);if(r.length>0)throw Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,t])}(e),[l,j]=(0,s.useState)(()=>(function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}let r=t.find(e=>e.default)??t[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:n,tabValues:i})),[x,m]=function(e){let{queryString:n=!1,groupId:t}=e,r=(0,d.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c._X)(i),(0,s.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})},[i,r])]}({queryString:t,groupId:r}),[b,f]=function(e){let{groupId:n}=e,t=n?`docusaurus.tab.${n}`:null,[r,i]=(0,h.Nk)(t);return[r,(0,s.useCallback)(e=>{t&&i.set(e)},[t,i])]}({groupId:r}),g=(()=>{let e=x??b;return p({value:e,tabValues:i})?e:null})();return(0,o.Z)(()=>{g&&j(g)},[g]),{selectedValue:l,selectValue:(0,s.useCallback)(e=>{if(!p({value:e,tabValues:i}))throw Error(`Can't select invalid tab value=${e}`);j(e),m(e),f(e)},[m,f,i]),tabValues:i}}(e);return(0,r.jsxs)("div",{className:(0,i.Z)("tabs-container","tabList_J5MA"),children:[(0,r.jsx)(x,{...n,...e}),(0,r.jsx)(m,{...n,...e})]})}function f(e){let n=(0,j.Z)();return(0,r.jsx)(b,{...e,children:u(e.children)},String(n))}},80980:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return l}});var r=t(27378);let s={},i=r.createContext(s);function l(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);