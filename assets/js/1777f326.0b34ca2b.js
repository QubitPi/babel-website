"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["6988"],{2931:function(e,t,n){n.r(t),n.d(t,{metadata:()=>s,contentTitle:()=>r,default:()=>h,assets:()=>a,toc:()=>d,frontMatter:()=>l});var s=JSON.parse('{"id":"roadmap","title":"Babel Roadmap","description":"This document outlines some of the improvements our team members would like to work on during this year.","source":"@site/../docs/roadmap.md","sourceDirName":".","slug":"/roadmap","permalink":"/docs/roadmap","draft":false,"unlisted":false,"editUrl":"https://github.com/babel/website/edit/main/docs/../docs/roadmap.md","tags":[],"version":"current","frontMatter":{"id":"roadmap","title":"Babel Roadmap","sidebar_label":"Roadmap"},"sidebar":"docs","previous":{"title":"transform-flow-strip-types","permalink":"/docs/babel-plugin-transform-flow-strip-types"},"next":{"title":"Caveats","permalink":"/docs/caveats"}}'),i=n("24246"),o=n("80980");let l={id:"roadmap",title:"Babel Roadmap",sidebar_label:"Roadmap"},r=void 0,a={},d=[{value:"Babel 2021 Roadmap",id:"babel-2021-roadmap",level:2},{value:"Babel 8",id:"babel-8",level:3},{value:"Implement new TC39 proposals",id:"implement-new-tc39-proposals",level:3},{value:"Move <code>@babel/preset-env</code> into <code>@babel/core</code>",id:"move-babelpreset-env-into-babelcore",level:3},{value:"Continue developing the <code>babel-polyfills</code> project",id:"continue-developing-the-babel-polyfills-project",level:3},{value:"Expand <code>targets</code> usage for granular transforms",id:"expand-targets-usage-for-granular-transforms",level:3},{value:"Investigate new compiler <code>assumptions</code>",id:"investigate-new-compiler-assumptions",level:3},{value:"Overhaul the Babel REPL",id:"overhaul-the-babel-repl",level:3},{value:"Educational/Debugging Tooling",id:"educationaldebugging-tooling",level:3}];function c(e){let t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"This document outlines some of the improvements our team members would like to work on during this year."}),"\n",(0,i.jsxs)(t.p,{children:["This is far from being a complete list of all the new features or important changes that we'll bring to Babel, but it's a good summary if you are interested in the general direction that the project is moving toward. We may not actually finish every listed point or may delay some of them to the next year. Some of them have clear starting and ending points, while others need more research or ",(0,i.jsx)(t.a,{href:"https://github.com/babel/rfcs",children:"RFCs"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If your company is interested and would like to directly sponsor any particular item please ",(0,i.jsx)(t.a,{href:"mail:team@babeljs.io",children:"reach out"}),"!"]}),"\n",(0,i.jsx)(t.h2,{id:"babel-2021-roadmap",children:"Babel 2021 Roadmap"}),"\n",(0,i.jsx)(t.h3,{id:"babel-8",children:"Babel 8"}),"\n",(0,i.jsx)(t.p,{children:"We have been talking about the Babel 8 release for more than one year (we initially scheduled it about one year ago)! However, we are now closer then ever to its release!"}),"\n",(0,i.jsxs)(t.p,{children:["Most of the remaining tasks are in the ",(0,i.jsx)(t.a,{href:"https://github.com/babel/babel/issues/10746",children:"tracking issue"}),", but there are still a few blockers:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We want to drop support for ",(0,i.jsx)(t.a,{href:"https://github.com/nodejs/Release",children:"Node.js 10"}),", which stops being maintained on 2021-04-30."]}),"\n",(0,i.jsx)(t.li,{children:"We would like to release Babel as a pure ESM package. We are now in the process of converting our sources to be compatible with Node.js' ESM implementation, and while doing so, we are examining how we can make it easier for people that currently use Babel to compile ESM to CJS."}),"\n",(0,i.jsxs)(t.li,{children:["We are trying to align our TypeScript AST with the ",(0,i.jsx)(t.a,{href:"https://github.com/typescript-eslint/typescript-eslint/",children:(0,i.jsx)(t.code,{children:"typescript-eslint"})})," project. Our ASTs are ",(0,i.jsx)(t.em,{children:"almost"})," identical, but we need to introduce some small breaking changes to fully align."]}),"\n",(0,i.jsx)(t.li,{children:'Our release infrastructure doesn\'t support yet pre-releases, or using multiple "main" branches (one for Babel 8 and one for Babel 7).'}),"\n",(0,i.jsx)(t.li,{children:"We haven't figured out yet a policy for Babel 7 maintenance."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"implement-new-tc39-proposals",children:"Implement new TC39 proposals"}),"\n",(0,i.jsx)(t.p,{children:"Babel can currently parse all the Stage 3 proposals, and we can transform all of them except for top-level await, import assertions and JSON modules (which are best handled by bundlers working with the dependencies graph)."}),"\n",(0,i.jsx)(t.p,{children:"We support all the Stage 2 proposals except for:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The new iteration of the decorators proposal (we need to implement both parsing and transform);"}),"\n",(0,i.jsx)(t.li,{children:"Transform for the Module Blocks proposal (we implemented parsing in Babel 7.13.0)."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We will implement support for decorators, and investigate if and how we can implement a transform for module blocks."}),"\n",(0,i.jsx)(t.p,{children:"While we don't support many Stage 1 proposals, there have been recent updates to the pipeline operator and to do expressions. Since we already support those proposals and the community is quite excited about them, we will update our implementations."}),"\n",(0,i.jsx)(t.p,{children:"There are also other proposals (such as pattern matching) that we have not yet implemented because their champions expect to do significant changes to the syntax and semantics. However, we are closely following their development, and will implement them in Babel as soon as they stabilize a bit."}),"\n",(0,i.jsxs)(t.h3,{id:"move-babelpreset-env-into-babelcore",children:["Move ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," into ",(0,i.jsx)(t.code,{children:"@babel/core"})]}),"\n",(0,i.jsx)(t.p,{children:"A minimal Babel transforming setup requires at least three packages:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"@babel/core"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"@babel/preset-env"})}),"\n",(0,i.jsxs)(t.li,{children:['a Babel "runner" (',(0,i.jsx)(t.code,{children:"@babel/cli"}),", ",(0,i.jsx)(t.code,{children:"babel-loader"}),", ",(0,i.jsx)(t.code,{children:"@rollup/plugin-babel"}),", etc)"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Moving ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," directly into ",(0,i.jsx)(t.code,{children:"@babel/core"})," has two big advantages:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["It will be easier to configure Babel in simple projects, you would only need to enable a ",(0,i.jsx)(t.code,{children:"compileJS: true"})," option in ",(0,i.jsx)(t.code,{children:"babel.config.json"})," (or it could even be the default in the future -- it can't be default as ",(0,i.jsx)(t.code,{children:"@babel/eslint-parser"})," does not compile the source)"]}),"\n",(0,i.jsxs)(t.li,{children:["It will make sure that the plugin versions are in sync with the ",(0,i.jsx)(t.code,{children:"@babel/core"})," version, avoiding most of the bugs caused by mismatched/incompatible packages versions"]}),"\n",(0,i.jsxs)(t.li,{children:["When we move to ESM, it will be hard to resolve and load plugin synchronously in ",(0,i.jsx)(t.code,{children:"transformSync"}),". This prevents it from being a problem."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["There is already ",(0,i.jsx)(t.a,{href:"https://github.com/babel/rfcs/pull/10",children:"a RFC"})," to move ",(0,i.jsx)(t.em,{children:"plugins"})," for stable ECMAScript features in ",(0,i.jsx)(t.code,{children:"@babel/core"}),", which is the first step in this direction."]}),"\n",(0,i.jsxs)(t.p,{children:["With our current ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," architecture, we would need to specially handle official plugins to automatically enable or disable them based on ",(0,i.jsx)(t.code,{children:"targets"}),".\nHowever, this has two drawbacks:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Compatibility data for a specific plugin is completely separated from the plugin implementation (it's not even a dependency, more something like an internal implicit peer dependency: plugin -> @babel/core -> @babel/compat-data);"}),"\n",(0,i.jsxs)(t.li,{children:["Official plugins would get special treatment from ",(0,i.jsx)(t.code,{children:"@babel/core"}),", but we want to make sure that third-party plugins have the same capabilities as official plugins."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"continue-developing-the-babel-polyfills-project",children:["Continue developing the ",(0,i.jsx)(t.code,{children:"babel-polyfills"})," project"]}),"\n",(0,i.jsxs)(t.p,{children:["We have already decided to remove the older ",(0,i.jsx)(t.code,{children:"core-js@2"})," support from ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," in Babel 8. We also want to stop promoting a specific third-party polyfill, which might give our users the impression that it's part of Babel itself."]}),"\n",(0,i.jsx)(t.p,{children:"This might happen in two different ways:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We just remove ",(0,i.jsx)(t.code,{children:"core-js@3"})," from ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," in Babel 8, encouraging users to migrate to ",(0,i.jsx)(t.code,{children:"babel-plugin-polyfill-corejs3"})," (which is what ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," internally uses starting from version 7.10.0)"]}),"\n",(0,i.jsxs)(t.li,{children:["We can keep ",(0,i.jsx)(t.code,{children:"core-js@3"})," support in ",(0,i.jsx)(t.code,{children:"@babel/preset-env"}),", but not migrate it to ",(0,i.jsx)(t.code,{children:"@babel/core"})," when we'll move the transform plugins."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Whichever path we take, we would like to offer at least one alternative to our users when they'll need to update the ",(0,i.jsx)(t.code,{children:"core-js"})," integration in their configuration. ",(0,i.jsx)(t.code,{children:"core-js"})," is a really good polyfill that ensures the highest possible spec compliancy, but users may prefer different trade-offs."]}),"\n",(0,i.jsxs)(t.p,{children:["(",(0,i.jsx)(t.a,{href:"https://github.com/nicolo-ribaudo",children:"Nicol\xf2"}),") is working with ",(0,i.jsx)(t.a,{href:"https://github.com/ljharb",children:"@ljharb"})," to make sure that the ",(0,i.jsxs)(t.a,{href:"https://github.com/es-shims/",children:[(0,i.jsx)(t.code,{children:"@es-shims"})," project"]})," supports at least all the ES2015+ features (we actually aim for ES5+), so that Babel users are free to choose between at least two options."]}),"\n",(0,i.jsxs)(t.p,{children:["This needs to happen ",(0,i.jsx)(t.em,{children:"before"})," dropping built-in support for ",(0,i.jsx)(t.code,{children:"core-js@3"}),", so that people interested in ",(0,i.jsx)(t.code,{children:"es-shims"})," don't have to migrate twice."]}),"\n",(0,i.jsxs)(t.h3,{id:"expand-targets-usage-for-granular-transforms",children:["Expand ",(0,i.jsx)(t.code,{children:"targets"})," usage for granular transforms"]}),"\n",(0,i.jsxs)(t.p,{children:["Since the beginning, ",(0,i.jsx)(t.code,{children:"@babel/preset-env"})," has used the ",(0,i.jsx)(t.code,{children:"targets"})," option to automatically enable or disable transform plugins."]}),"\n",(0,i.jsx)(t.p,{children:"However, there isn't a 1-to-1 mapping between Babel plugins and features implemented in browsers."}),"\n",(0,i.jsx)(t.p,{children:"For example, we have a single plugin for the different class fields types (public and private, static and instance), but browsers have varying compatibility matrices:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Firefox 73 and Safari 14 support only public instance fields"}),"\n",(0,i.jsx)(t.li,{children:"Firefox 75+ supports public instance and static fields"}),"\n",(0,i.jsx)(t.li,{children:"Chrome 79+ supports public and private fields, but doesn't support private fields in some optional chaining expressions"}),"\n",(0,i.jsx)(t.li,{children:"Chrome 84+ fully supports private fields, and also private methods"}),"\n",(0,i.jsxs)(t.li,{children:["Safari TP 121 fully supports private fields (even with ",(0,i.jsx)(t.code,{children:"?."}),"), but it doesn't support private methods"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Creating a plugin for each feature is sub-optimal. For example, we can convert private methods to private fields and then, if needed, convert them to older syntax. However, we can generate better/optimized output by directly converting private methods down to older syntax without the intermediate step if we know that it needs to be transpiled down."}),"\n",(0,i.jsxs)(t.p,{children:["Since Babel 7.13.0, we can read the ",(0,i.jsx)(t.code,{children:"targets"})," option directly inside a plugin, we can modify our plugins to automatically perform a ",(0,i.jsx)(t.em,{children:"partial"})," compilation of a given ECMAScript feature, which would give advantages in the output size and runtime performance."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Prior Art"})}),"\n",(0,i.jsxs)(t.p,{children:["This approach isn't completely new. Thanks to a collaboration with ",(0,i.jsx)(t.a,{href:"https://twitter.com/_developit",children:"@_developit"}),", in Babel 7.9.0 we introduced a new ",(0,i.jsx)(t.code,{children:"bugfixes: true"})," option for ",(0,i.jsx)(t.code,{children:"@babel/preset-env"}),". When this option is enabled, and when using ",(0,i.jsx)(t.code,{children:"esmodules: true"})," as the compilation target, we only partially compile ",(0,i.jsx)(t.a,{href:"https://github.com/babel/preset-modules#features-supported",children:"some features"}),". This what made us initially think about this possibility, but the current partial transforms are less useful when using more modern targets (for example, ",(0,i.jsx)(t.code,{children:"defaults, not ie 11"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["We also already use the ",(0,i.jsx)(t.code,{children:"targets"})," option to decide whether we can use ",(0,i.jsx)(t.code,{children:"Object.assign"})," when compiling object spread or not."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Action Points"})}),"\n",(0,i.jsx)(t.p,{children:"This goal can be split into two big tasks that can be done in parallel:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We need to identify ",(0,i.jsx)(t.em,{children:"where"})," these optimizations can be useful by collecting real-world browserslist queries and by simulating how popular queries (for example, ",(0,i.jsx)(t.code,{children:"defaults"})," or ",(0,i.jsx)(t.code,{children:">2%, not dead"}),") will evolve in the future."]}),"\n",(0,i.jsx)(t.li,{children:"We need to actually implement the necessary optimizations, making sure that they still work well with the other plugins (since they would highly increase the number of possible transform combinations)."}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"investigate-new-compiler-assumptions",children:["Investigate new compiler ",(0,i.jsx)(t.code,{children:"assumptions"})]}),"\n",(0,i.jsxs)(t.p,{children:["In Babel 7.13.0 we introduced a new top-level ",(0,i.jsx)(t.a,{href:"https://babeljs.io/docs/en/options#assumptions",children:(0,i.jsx)(t.code,{children:"assumptions"})})," option, to formalize what the ",(0,i.jsx)(t.code,{children:"loose"})," mode option does and offer more granular control to our users (since often they can only enable ",(0,i.jsx)(t.em,{children:"some"})," assumptions and not all of them)."]}),"\n",(0,i.jsxs)(t.p,{children:["However, we only included options for assumptions we ",(0,i.jsx)(t.em,{children:"already"})," made when compiling in ",(0,i.jsx)(t.code,{children:"loose"})," mode. We can now investigate what new assumptions our users might need."]}),"\n",(0,i.jsx)(t.p,{children:"There are already some proposals, such as:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/babel/babel/issues/8222",children:"#8222"})," - assume that all the ESM imports are actually immutable, avoiding the code needed for live bindings."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/babel/babel/issues/11356",children:"#11356"})," - assume that compiled classes do not extends native classes, avoiding the runtime performance cost needed to instantiate possibly native classes."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We can find which new assumptions we should implement, by:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'Manually checking which features we compile to "non-obvious" output, which is usually caused by edge cases that many developers don\'t care about.'}),"\n",(0,i.jsx)(t.li,{children:"Asking for feedback from the community, since developers can test which assumptions work and which don't on their applications."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"overhaul-the-babel-repl",children:"Overhaul the Babel REPL"}),"\n",(0,i.jsx)(t.p,{children:"The Babel REPL is a convenient playground to learn how Babel transpiles source code."}),"\n",(0,i.jsx)(t.p,{children:"Current limits:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The REPL does not support ",(0,i.jsx)(t.code,{children:"assumptions"})," config. Although we have a dedicated per-assumption basis mini REPL on ",(0,i.jsx)(t.a,{href:"https://babel.dev/assumptions",children:"https://babel.dev/assumptions"}),", currently we can not show how these ",(0,i.jsx)(t.code,{children:"assumptions"})," might work together"]}),"\n",(0,i.jsxs)(t.li,{children:["The REPL does not support plugin options. Some plugins have required options, such as ",(0,i.jsx)(t.code,{children:"@babel/plugin-proposal-record-and-tuple"})," and ",(0,i.jsx)(t.code,{children:"@babel/plugin-proposal-decorators"}),"\n",(0,i.jsx)(t.a,{href:"https://github.com/babel/website/issues/1292",children:"https://github.com/babel/website/issues/1292"}),", ",(0,i.jsx)(t.a,{href:"https://github.com/babel/website/issues/2224",children:"https://github.com/babel/website/issues/2224"}),", ",(0,i.jsx)(t.a,{href:"https://github.com/babel/website/pull/1970",children:"https://github.com/babel/website/pull/1970"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Features good to have:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"AST Explorer (integrate with existing one)"}),"\n",(0,i.jsx)(t.li,{children:"stderr with complete stack trace as error log"}),"\n",(0,i.jsx)(t.li,{children:"stdout as output"}),"\n",(0,i.jsx)(t.li,{children:"Change Babel version from UI"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["At least 15% of open issues in babel-website are related to the REPL: ",(0,i.jsx)(t.a,{href:"https://github.com/babel/website/issues?q=is%3Aissue+is%3Aopen+label%3Arepl",children:"https://github.com/babel/website/issues?q=is%3Aissue+is%3Aopen+label%3Arepl"})]}),"\n",(0,i.jsx)(t.h3,{id:"educationaldebugging-tooling",children:"Educational/Debugging Tooling"}),"\n",(0,i.jsx)(t.p,{children:"Related to the REPL/ASTExplorer, we could do with more tooling to help with general plugin development for ourselves and 3rd-party plugins. This is rather exploratory in nature: different visualizations for the AST itself, debugging, etc."}),"\n",(0,i.jsx)(t.p,{children:"Some things already in progress Henry has been working on and off on:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://codesandbox.io/s/babel-repl-custom-plugin-7s08o",children:"Codesandbox"})," for making a simple Babel plugin in the same vein as ",(0,i.jsx)(t.a,{href:"https://astexplorer.net",children:"https://astexplorer.net"})," but with custom configs."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://twitter.com/left_pad/status/1367941962083471361?s=20",children:"Visualization"})," of input to output mapping to help understand how Babel transforms its code. Could be useful even for documentation in getting JavaScript users familiar with new syntax or a specific demo of a transform."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://twitter.com/left_pad/status/1298792944099561473?s=20",children:"Mapping"})," of input to output like a sourcemap type structure. Can do a reverse mapping to find out what plugin caused the code to be outputted a certain way which helps with debugging."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For an interactive example of what we are thinking about: ",(0,i.jsx)(t.a,{href:"https://babel-explorer.netlify.app/",children:"https://babel-explorer.netlify.app/"})," (click and hold the mouse in the bottom sector!)"]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},80980:function(e,t,n){n.d(t,{Z:function(){return r},a:function(){return l}});var s=n(27378);let i={},o=s.createContext(i);function l(e){let t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);