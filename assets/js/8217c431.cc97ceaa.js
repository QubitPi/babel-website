"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2404],{35318:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return b}});var a=n(27378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,b=m["".concat(s,".").concat(d)]||m[d]||u[d]||l;return n?a.createElement(b,o(o({ref:t},c),{},{components:n})):a.createElement(b,o({ref:t},c))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[m]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},32626:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return b},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return m}});var a=n(25773),r=n(30808),l=(n(27378),n(35318)),o=["components"],i={id:"babel-core",title:"@babel/core"},s=void 0,p={unversionedId:"babel-core",id:"babel-core",title:"@babel/core",description:"All transformations will use your local configuration files.",source:"@site/../docs/core.md",sourceDirName:".",slug:"/babel-core",permalink:"/babel-website/docs/babel-core",draft:!1,editUrl:"https://github.com/babel/website/edit/main/docs/../docs/core.md",tags:[],version:"current",frontMatter:{id:"babel-core",title:"@babel/core"},sidebar:"docs",previous:{title:"@babel/parser",permalink:"/babel-website/docs/babel-parser"},next:{title:"@babel/generator",permalink:"/babel-website/docs/babel-generator"}},c={},m=[{value:"transform",id:"transform",level:2},{value:"transformSync",id:"transformsync",level:2},{value:"transformAsync",id:"transformasync",level:2},{value:"transformFile",id:"transformfile",level:2},{value:"transformFileSync",id:"transformfilesync",level:2},{value:"transformFileAsync",id:"transformfileasync",level:2},{value:"transformFromAst",id:"transformfromast",level:2},{value:"transformFromAstSync",id:"transformfromastsync",level:2},{value:"transformFromAstAsync",id:"transformfromastasync",level:2},{value:"parse",id:"parse",level:2},{value:"parseSync",id:"parsesync",level:2},{value:"parseAsync",id:"parseasync",level:2},{value:"Advanced APIs",id:"advanced-apis",level:2},{value:"loadOptions",id:"loadoptions",level:3},{value:"loadPartialConfig",id:"loadpartialconfig",level:3},{value:"createConfigItem",id:"createconfigitem",level:3},{value:"<code>ConfigItem</code> type",id:"configitem-type",level:3},{value:"DEFAULT_EXTENSIONS",id:"default_extensions",level:2},{value:"Options",id:"options",level:2}],u={toc:m},d="wrapper";function b(e){var t=e.components,n=(0,r.Z)(e,o);return(0,l.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'var babel = require("@babel/core");\nimport { transform } from "@babel/core";\nimport * as babel from "@babel/core";\n')),(0,l.kt)("p",null,"All transformations will use your local ",(0,l.kt)("a",{parentName:"p",href:"/babel-website/docs/config-files"},"configuration files"),"."),(0,l.kt)("h2",{id:"transform"},"transform"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transform(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object, callback: Function)")),(0,l.kt)("p",null,"Transforms the passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"code"),". Calling a callback with an object with the generated code,\nsource map, and AST."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n});\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'babel.transform("code();", options, function(err, result) {\n  result.code;\n  result.map;\n  result.ast;\n});\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Compat Note:"),(0,l.kt)("p",{parentName:"blockquote"},"In Babel 6, this method was synchronous and ",(0,l.kt)("inlineCode",{parentName:"p"},"transformSync")," did not exist. For backward-compatibility, this function will behave synchronously if no callback is given. If you're starting with Babel 7 and need synchronous behavior, please use ",(0,l.kt)("inlineCode",{parentName:"p"},"transformSync")," since this backward-compatibility will be dropped in Babel 8.")),(0,l.kt)("h2",{id:"transformsync"},"transformSync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformSync(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Transforms the passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"code"),". Returning an object with the generated code,\nsource map, and AST."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transformSync(code, options); // => { code, map, ast }\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'var result = babel.transformSync("code();", options);\nresult.code;\nresult.map;\nresult.ast;\n')),(0,l.kt)("h2",{id:"transformasync"},"transformAsync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformAsync(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Transforms the passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"code"),". Returning an promise for an object with the\ngenerated code, source map, and AST."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transformAsync(code, options); // => Promise<{ code, map, ast }>\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'babel.transformAsync("code();", options).then(result => {\n  result.code;\n  result.map;\n  result.ast;\n});\n')),(0,l.kt)("h2",{id:"transformfile"},"transformFile"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFile(filename: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object, callback: Function)")),(0,l.kt)("p",null,"Asynchronously transforms the entire contents of a file."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transformFile(filename, options, callback);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'babel.transformFile("filename.js", options, function(err, result) {\n  result; // => { code, map, ast }\n});\n')),(0,l.kt)("h2",{id:"transformfilesync"},"transformFileSync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFileSync(filename: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Synchronous version of ",(0,l.kt)("inlineCode",{parentName:"p"},"babel.transformFile"),". Returns the transformed contents of\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"filename"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transformFileSync(filename, options); // => { code, map, ast }\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'babel.transformFileSync("filename.js", options).code;\n')),(0,l.kt)("h2",{id:"transformfileasync"},"transformFileAsync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFileAsync(filename: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Promise version of ",(0,l.kt)("inlineCode",{parentName:"p"},"babel.transformFile"),". Returns a promise for the transformed\ncontents of the ",(0,l.kt)("inlineCode",{parentName:"p"},"filename"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},"babel.transformFileAsync(filename, options); // => Promise<{ code, map, ast }>\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'babel.transformFileAsync("filename.js", options).then(result => {\n  result.code;\n});\n')),(0,l.kt)("h2",{id:"transformfromast"},"transformFromAst"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFromAst(ast: Object, code?: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object, callback: Function): FileNode | null")),(0,l.kt)("p",null,"Given an ",(0,l.kt)("a",{parentName:"p",href:"https://astexplorer.net/"},"AST"),", transform it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'const sourceCode = "if (true) return;";\nconst parsedAst = babel.parseSync(sourceCode, {\n  parserOpts: { allowReturnOutsideFunction: true },\n});\nbabel.transformFromAst(parsedAst, sourceCode, options, function(err, result) {\n  const { code, map, ast } = result;\n});\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Compat Note:"),(0,l.kt)("p",{parentName:"blockquote"},"In Babel 6, this method was synchronous and ",(0,l.kt)("inlineCode",{parentName:"p"},"transformFromAstSync")," did not exist. For backward-compatibility, this function will behave synchronously if no callback is given. If you're starting with Babel 7 and need synchronous behavior, please use ",(0,l.kt)("inlineCode",{parentName:"p"},"transformFromAstSync")," since this backward-compatibility will be dropped in Babel 8.")),(0,l.kt)("h2",{id:"transformfromastsync"},"transformFromAstSync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFromAstSync(ast: Object, code?: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Given an ",(0,l.kt)("a",{parentName:"p",href:"https://astexplorer.net/"},"AST"),", transform it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'const sourceCode = "if (true) return;";\nconst parsedAst = babel.parseSync(sourceCode, {\n  parserOpts: { allowReturnOutsideFunction: true },\n});\nconst { code, map, ast } = babel.transformFromAstSync(\n  parsedAst,\n  sourceCode,\n  options\n);\n')),(0,l.kt)("h2",{id:"transformfromastasync"},"transformFromAstAsync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.transformFromAstAsync(ast: Object, code?: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Given an ",(0,l.kt)("a",{parentName:"p",href:"https://astexplorer.net/"},"AST"),", transform it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'const sourceCode = "if (true) return;";\nbabel\n  .parseAsync(sourceCode, { parserOpts: { allowReturnOutsideFunction: true } })\n  .then(parsedAst => {\n    return babel.transformFromAstAsync(parsedAst, sourceCode, options);\n  })\n  .then(({ code, map, ast }) => {\n    // ...\n  });\n')),(0,l.kt)("h2",{id:"parse"},"parse"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.parse(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object, callback: Function)")),(0,l.kt)("p",null,"Given some code, parse it using Babel's standard behavior. Referenced presets and\nplugins will be loaded such that optional syntax plugins are automatically\nenabled."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Compat Note:"),(0,l.kt)("p",{parentName:"blockquote"},"In Babel 7's early betas, this method was synchronous and ",(0,l.kt)("inlineCode",{parentName:"p"},"parseSync")," did not exist. For backward-compatibility,\nthis function will behave synchronously if no callback is given. If you're starting with Babel 7 stable\nand need synchronous behavior, please use ",(0,l.kt)("inlineCode",{parentName:"p"},"parseSync")," since this backward-compatibility will be dropped in Babel 8.")),(0,l.kt)("h2",{id:"parsesync"},"parseSync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.parseSync(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Returns an AST."),(0,l.kt)("p",null,"Given some code, parse it using Babel's standard behavior. Referenced presets and\nplugins will be loaded such that optional syntax plugins are automatically\nenabled."),(0,l.kt)("h2",{id:"parseasync"},"parseAsync"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.parseAsync(code: string, ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Returns a promise for an AST."),(0,l.kt)("p",null,"Given some code, parse it using Babel's standard behavior. Referenced presets and\nplugins will be loaded such that optional syntax plugins are automatically\nenabled."),(0,l.kt)("h2",{id:"advanced-apis"},"Advanced APIs"),(0,l.kt)("p",null,"Many systems that wrap Babel like to automatically inject plugins and presets,\nor override options. To accomplish this goal, Babel exposes several functions\nthat aid in loading the configuration part-way without transforming."),(0,l.kt)("h3",{id:"loadoptions"},"loadOptions"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.loadOptions(",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object)")),(0,l.kt)("p",null,"Resolve Babel's options fully, resulting in an options object where:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.plugins")," is a full list of ",(0,l.kt)("inlineCode",{parentName:"li"},"Plugin")," instances."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.presets")," is empty and all presets are flattened into ",(0,l.kt)("inlineCode",{parentName:"li"},"opts"),"."),(0,l.kt)("li",{parentName:"ul"},"It can be safely passed back to Babel. Fields like ",(0,l.kt)("a",{parentName:"li",href:"/babel-website/docs/options#babelrc"},(0,l.kt)("inlineCode",{parentName:"a"},'"babelrc"'))," have been set to\n",(0,l.kt)("inlineCode",{parentName:"li"},"false")," so that later calls to Babel will not make a second attempt to load\nconfig files.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Plugin")," instances aren't meant to be manipulated directly, but often\ncallers will serialize this ",(0,l.kt)("inlineCode",{parentName:"p"},"opts")," to JSON to use it as a cache key representing\nthe options Babel has received. Caching on this isn't 100% guaranteed to\ninvalidate properly, but it is the best we have at the moment."),(0,l.kt)("h3",{id:"loadpartialconfig"},"loadPartialConfig"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.loadPartialConfig(",(0,l.kt)("a",{parentName:"p",href:"#options"},"options?"),": Object): PartialConfig")),(0,l.kt)("p",null,"To allow systems to easily manipulate and validate a user's config, this function\nresolves the plugins and presets and proceeds no further. The expectation is\nthat callers will take the config's ",(0,l.kt)("inlineCode",{parentName:"p"},".options"),", manipulate it as they see fit\nand pass it back to Babel again."),(0,l.kt)("p",null,"This function accepts one additional option as part of the options object in addition to the standard ",(0,l.kt)("a",{parentName:"p",href:"#options"},"options"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"showIgnoredFiles"),".\nWhen set to true, ",(0,l.kt)("inlineCode",{parentName:"p"},"loadPartialConfig")," always returns a result when a file is ignored, rather than ",(0,l.kt)("inlineCode",{parentName:"p"},"null"),".\nThis is useful in order to allow the caller to access the list of files that influenced this outcome, e.g.\nfor watch mode. The caller can determine whether a file was ignored based on the returned ",(0,l.kt)("inlineCode",{parentName:"p"},"fileHandling")," property."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"babelrc: string | void")," - The path of the ",(0,l.kt)("a",{parentName:"li",href:"/babel-website/docs/config-files#file-relative-configuration"},"file-relative configuration")," file, if there was one."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"babelignore: string | void")," - The path of the ",(0,l.kt)("inlineCode",{parentName:"li"},".babelignore")," file, if there was one."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"config: string | void")," - The path of the ",(0,l.kt)("a",{parentName:"li",href:"/babel-website/docs/config-files#project-wide-configuration"},"project-wide config file")," file, if there was one."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"options: ValidatedOptions")," - The partially resolved options, which can be manipulated and passed back to Babel again.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"plugins: Array<ConfigItem>")," - See below."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"presets: Array<ConfigItem>")," - See below."),(0,l.kt)("li",{parentName:"ul"},"It can be safely passed back to Babel. Options like ",(0,l.kt)("a",{parentName:"li",href:"/babel-website/docs/options#babelrc"},(0,l.kt)("inlineCode",{parentName:"a"},'"babelrc"'))," have been set\nto false so that later calls to Babel will not make a second attempt to\nload config files."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hasFilesystemConfig(): boolean")," - Check if the resolved config loaded any settings from the filesystem."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fileHandling")," - This is set to ",(0,l.kt)("inlineCode",{parentName:"li"},'"transpile"'),", ",(0,l.kt)("inlineCode",{parentName:"li"},'"ignored"'),", or ",(0,l.kt)("inlineCode",{parentName:"li"},'"unsupported"')," to indicate to the caller what to do with this file."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"files")," - A ",(0,l.kt)("inlineCode",{parentName:"li"},"Set")," of file paths that were read to build the resulting config, including project wide config files, local config files,\nextended config files, ignore files, etc. Useful for implementing watch mode or cache invalidation.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"#configitem-type"},(0,l.kt)("inlineCode",{parentName:"a"},"ConfigItem"))," instances expose properties to introspect the values, but each\nitem should be treated as immutable. If changes are desired, the item should be\nremoved from the list and replaced with either a normal Babel config value, or\nwith a replacement item created by ",(0,l.kt)("inlineCode",{parentName:"p"},"babel.createConfigItem"),". See that\nfunction for information about ",(0,l.kt)("inlineCode",{parentName:"p"},"ConfigItem")," fields."),(0,l.kt)("h3",{id:"createconfigitem"},"createConfigItem"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.createConfigItem(value: string | {} | Function | ","[string | {} | Function, {} | void]",', { dirname?: string, type?: "preset" | "plugin" }): ConfigItem')),(0,l.kt)("p",null,"Allows build tooling to create and cache config items up front. If this function\nis called multiple times for a given plugin, Babel will call the plugin's function itself\nmultiple times. If you have a clear set of expected plugins and presets to\ninject, pre-constructing the config items would be recommended."),(0,l.kt)("h3",{id:"configitem-type"},(0,l.kt)("inlineCode",{parentName:"h3"},"ConfigItem")," type"),(0,l.kt)("p",null,"Each ",(0,l.kt)("inlineCode",{parentName:"p"},"ConfigItem")," exposes all of the information Babel knows. The fields are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value: {} | Function")," - The resolved value of the plugin."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"options: {} | void")," - The options object passed to the plugin."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"dirname: string")," - The path that the options are relative to."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"name: string | void")," - The name that the user gave the plugin instance, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"plugins: [ ['env', {}, 'my-env'] ]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file: Object | void")," - Information about the plugin's file, if Babel knows it.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"request: string")," - The file that the user requested, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},'"@babel/env"')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"resolved: string")," - The full path of the resolved file, e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},'"/tmp/node_modules/@babel/preset-env/lib/index.js"'))))),(0,l.kt)("h2",{id:"default_extensions"},"DEFAULT_EXTENSIONS"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"babel.DEFAULT_EXTENSIONS: readonly string[];")),(0,l.kt)("p",null,'A list of default extensions supported by babel (".js", ".jsx", ".es6", ".es", ".mjs", "cjs").\nThis list is used by @babel/register and @babel/cli to determine which files need transpiling.\nExtending this list isn\'t possible, however @babel/cli does provide ways to support other extensions with ',(0,l.kt)("inlineCode",{parentName:"p"},"--extensions"),"."),(0,l.kt)("h2",{id:"options"},"Options"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/babel-website/docs/options"},"the full option list here"),"."))}b.isMDXComponent=!0}}]);