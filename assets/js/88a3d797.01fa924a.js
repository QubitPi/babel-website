"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["6127"],{85410:function(e,s,t){t.r(s),t.d(s,{default:()=>p,frontMatter:()=>r,metadata:()=>n,assets:()=>l,toc:()=>d,contentTitle:()=>o});var n=JSON.parse('{"id":"assumptions","title":"Compiler assumptions","description":"By default Babel tries to compile your code so that it matches the native behavior as closely as possible. However, this sometimes means generating more output code, or slower output code, just to support some edge cases you don\'t care about.","source":"@site/../docs/assumptions.md","sourceDirName":".","slug":"/assumptions","permalink":"/docs/assumptions","draft":false,"unlisted":false,"editUrl":"https://github.com/babel/website/edit/main/docs/../docs/assumptions.md","tags":[],"version":"current","frontMatter":{"title":"Compiler assumptions","id":"assumptions"},"sidebar":"docs","previous":{"title":"Plugins List","permalink":"/docs/plugins-list"},"next":{"title":"Presets","permalink":"/docs/presets"}}'),i=t("85893"),a=t("50065");let r={title:"Compiler assumptions",id:"assumptions"},o=void 0,l={},d=[{value:"<code>arrayLikeIsIterable</code>",id:"arraylikeisiterable",level:2},{value:"<code>constantReexports</code>",id:"constantreexports",level:2},{value:"<code>constantSuper</code>",id:"constantsuper",level:2},{value:"<code>enumerableModuleMeta</code>",id:"enumerablemodulemeta",level:2},{value:"<code>ignoreFunctionLength</code>",id:"ignorefunctionlength",level:2},{value:"<code>ignoreToPrimitiveHint</code>",id:"ignoretoprimitivehint",level:2},{value:"<code>iterableIsArray</code>",id:"iterableisarray",level:2},{value:"<code>mutableTemplateObject</code>",id:"mutabletemplateobject",level:2},{value:"<code>noClassCalls</code>",id:"noclasscalls",level:2},{value:"<code>noDocumentAll</code>",id:"nodocumentall",level:2},{value:"<code>noIncompleteNsImportDetection</code>",id:"noincompletensimportdetection",level:2},{value:"<code>noNewArrows</code>",id:"nonewarrows",level:2},{value:"<code>noUninitializedPrivateFieldAccess</code>",id:"nouninitializedprivatefieldaccess",level:2},{value:"<code>objectRestNoSymbols</code>",id:"objectrestnosymbols",level:2},{value:"<code>privateFieldsAsProperties</code>",id:"privatefieldsasproperties",level:2},{value:"<code>privateFieldsAsSymbols</code>",id:"privatefieldsassymbols",level:2},{value:"<code>pureGetters</code>",id:"puregetters",level:2},{value:"<code>setClassMethods</code>",id:"setclassmethods",level:2},{value:"<code>setComputedProperties</code>",id:"setcomputedproperties",level:2},{value:"<code>setPublicClassFields</code>",id:"setpublicclassfields",level:2},{value:"<code>setSpreadProperties</code>",id:"setspreadproperties",level:2},{value:"<code>skipForOfIteratorClosing</code>",id:"skipforofiteratorclosing",level:2},{value:"<code>superIsCallableConstructor</code>",id:"superiscallableconstructor",level:2},{value:"Migrating from <code>@babel/preset-env</code>&#39;s <code>&quot;loose&quot;</code> and <code>&quot;spec&quot;</code> modes",id:"migrating-from-babelpreset-envs-loose-and-spec-modes",level:2}];function c(e){let s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components},{Details:t}=s;return t||function(e,s){throw Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"By default Babel tries to compile your code so that it matches the native behavior as closely as possible. However, this sometimes means generating more output code, or slower output code, just to support some edge cases you don't care about."}),"\n",(0,i.jsxs)(s.p,{children:["Since Babel 7.13.0, you can specify an ",(0,i.jsx)(s.code,{children:"assumptions"})," option in your configuration to tell Babel which assumptions it can make about your code, to better optimize the compilation result. ",(0,i.jsx)(s.em,{children:"Note"}),": this replaces the various ",(0,i.jsx)(s.code,{children:"loose"})," options in plugins in favor of top-level options that can apply to multiple plugins (",(0,i.jsx)(s.a,{href:"https://github.com/babel/rfcs/blob/master/rfcs/0003-top-level-assumptions.md",children:"RFC link"}),")."]}),"\n",(0,i.jsx)(s.p,{children:"For example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",metastring:'title="babel.config.json"',children:'{\n  "targets": ">0.5%",\n  "assumptions": {\n    "noDocumentAll": true,\n    "noClassCalls": true\n  },\n  "presets": ["@babel/preset-env"]\n}\n'})}),"\n",(0,i.jsx)(s.admonition,{type:"caution",children:(0,i.jsx)(s.p,{children:"This is advanced functionality. Please be careful when enabling assumptions, because they are not spec-compliant and may break your code in unexpected ways."})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["Are you migrating from ",(0,i.jsx)(s.code,{children:"@babel/preset-env"}),"'s ",(0,i.jsx)(s.code,{children:"loose"})," and ",(0,i.jsx)(s.code,{children:"spec"})," options to granular assumptions? Check ",(0,i.jsxs)(s.a,{href:"#migrating-from-babelpreset-envs-loose-and-spec-modes",children:['"Migrating from ',(0,i.jsx)(s.code,{children:"@babel/preset-env"}),"'s ",(0,i.jsx)(s.code,{children:'"loose"'})," and ",(0,i.jsx)(s.code,{children:'"spec"'}),' modes"']})," for the equivalent assumptions-based configuration, ready to be copied and pasted as a starting point."]})}),"\n",(0,i.jsx)(s.h2,{id:"arraylikeisiterable",children:(0,i.jsx)(s.code,{children:"arrayLikeIsIterable"})}),"\n",(0,i.jsxs)(s.p,{children:["When spreading or iterating an array-like object, assume that it implements a ",(0,i.jsx)(s.code,{children:"[Symbol.iterator]"})," method with the same behavior of the native ",(0,i.jsx)(s.code,{children:"Array.prototype[Symbol.iterator]"}),", and thus directly iterate over its element by index."]}),"\n",(0,i.jsx)(s.p,{children:"This can be useful, for example, to iterate DOM collections in older browsers."}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"arrayLikeIsIterable","data-plugins":"transform-destructuring,transform-spread,transform-for-of",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:'let images = $("img");\n\nfor (const img of images) {\n  console.log(img);\n}\n\nconst copy = [...images];\n'})})}),"\n",(0,i.jsx)(s.h2,{id:"constantreexports",children:(0,i.jsx)(s.code,{children:"constantReexports"})}),"\n",(0,i.jsx)(s.p,{children:"When re-exporting a binding from a module, assume that it doesn't change and thus it's safe to directly export it, as if you were doing"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:'import { value as val } from "dep";\n\nexport const value = val;\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"NOTE:"})," This also affects the ",(0,i.jsx)(s.code,{children:"transform-modules-umd"})," and ",(0,i.jsx)(s.code,{children:"transform-modules-amd"})," plugins."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"constantReexports","data-plugins":"transform-modules-commonjs",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:'export { value } from "dependency";\n'})})}),"\n",(0,i.jsx)(s.h2,{id:"constantsuper",children:(0,i.jsx)(s.code,{children:"constantSuper"})}),"\n",(0,i.jsxs)(s.p,{children:["The super class of a class can be changed at any time by using ",(0,i.jsx)(s.code,{children:"Object.setPrototypeOf"}),", making it impossible for Babel to statically know it. When this option is enabled, Babel assumes that it's never changed and thus it is always the value that was placed in the ",(0,i.jsx)(s.code,{children:"extends"})," clause in the class declaration."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"constantSuper","data-plugins":"transform-classes",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Child extends Base {\n  method() {\n    super.method(2);\n  }\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"enumerablemodulemeta",children:(0,i.jsx)(s.code,{children:"enumerableModuleMeta"})}),"\n",(0,i.jsxs)(s.p,{children:["When compiling ESM to CJS, Babel defines a ",(0,i.jsx)(s.code,{children:"__esModule"})," property on the ",(0,i.jsx)(s.code,{children:"module.exports"})," object. Assume that you never iterate over the keys of ",(0,i.jsx)(s.code,{children:"module.exports"})," or of ",(0,i.jsx)(s.code,{children:'require("your-module")'})," using ",(0,i.jsx)(s.code,{children:"for..in"})," or ",(0,i.jsx)(s.code,{children:"Object.keys"}),", and thus it's safe to define ",(0,i.jsx)(s.code,{children:"__esModule"})," as enumerable."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"enumerableModuleMeta","data-plugins":"transform-modules-commonjs",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"export const number = 2;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"ignorefunctionlength",children:(0,i.jsx)(s.code,{children:"ignoreFunctionLength"})}),"\n",(0,i.jsxs)(s.p,{children:["Functions have a ",(0,i.jsx)(s.code,{children:".length"})," property that reflect the number of parameters up to the last non-default parameter. When this option is enabled, assume that the compiled code does not rely on this ",(0,i.jsx)(s.code,{children:".length"})," property."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"ignoreFunctionLength","data-plugins":"transform-parameters",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"function fn(a, b = 2, c, d = 3) {\n  return a + b + c + d;\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"ignoretoprimitivehint",children:(0,i.jsx)(s.code,{children:"ignoreToPrimitiveHint"})}),"\n",(0,i.jsxs)(s.p,{children:["When using language features that might call the ",(0,i.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive",children:(0,i.jsx)(s.code,{children:"[Symbol.toPrimitive]"})})," method of objects, assume that they don't change their behavior based on the ",(0,i.jsx)(s.code,{children:"hint"})," parameter."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"ignoreToPrimitiveHint","data-plugins":"transform-template-literals",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let str = `a${foo}b`;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"iterableisarray",children:(0,i.jsx)(s.code,{children:"iterableIsArray"})}),"\n",(0,i.jsx)(s.p,{children:"When using an iterable object (in array destructuring, for-of or spreads), assume that it is an array."}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"iterableIsArray","data-plugins":"transform-for-of,transform-destructuring,transform-spread",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"const [first, ...rest] = obj;\n\ncall(first, ...obj);\nlet arr = [first, ...obj];\n\nfor (const el of obj) {\n  console.log(el);\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"mutabletemplateobject",children:(0,i.jsx)(s.code,{children:"mutableTemplateObject"})}),"\n",(0,i.jsxs)(s.p,{children:["Don't use ",(0,i.jsx)(s.code,{children:"Object.freeze"})," for the template object created for tagged template literals. This effectively means using the ",(0,i.jsx)(s.code,{children:"taggedTemplateLiteralLoose"})," helper instead of ",(0,i.jsx)(s.code,{children:"taggedTemplateLiteral"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"mutableTemplateObject","data-plugins":"transform-template-literals",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let str = tag`a`;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"noclasscalls",children:(0,i.jsx)(s.code,{children:"noClassCalls"})}),"\n",(0,i.jsxs)(s.p,{children:["When transforming classes, assume that they are always instantiate with ",(0,i.jsx)(s.code,{children:"new"})," and they are never called as functions."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"noClassCalls","data-plugins":"transform-classes",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Test {\n  constructor() {\n    this.x = 2;\n  }\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"nodocumentall",children:(0,i.jsx)(s.code,{children:"noDocumentAll"})}),"\n",(0,i.jsxs)(s.p,{children:["When using operators that check for ",(0,i.jsx)(s.code,{children:"null"})," or ",(0,i.jsx)(s.code,{children:"undefined"}),", assume that they are never used with the special value ",(0,i.jsx)(s.code,{children:"document.all"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"noDocumentAll","data-plugins":"proposal-optional-chaining,proposal-nullish-coalescing-operator",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let score = points ?? 0;\nlet name = user?.name;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"noincompletensimportdetection",children:(0,i.jsx)(s.code,{children:"noIncompleteNsImportDetection"})}),"\n",(0,i.jsxs)(s.p,{children:["Assume that no own property of a module export object is observed before initialization.\nFor example, when trying to access ",(0,i.jsx)(s.code,{children:"ns.foo"}),", it will return ",(0,i.jsx)(s.code,{children:"undefined"})," both with this assumption turned on or off. The\ndifference is that ",(0,i.jsx)(s.code,{children:'Object.prototype.hasOwnProperty.call(ns, "foo")'})," would return ",(0,i.jsx)(s.code,{children:"false"})," when\n",(0,i.jsx)(s.code,{children:"noIncompleteNsImportDetection: true"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"noIncompleteNsImportDetection","data-plugins":"transform-modules-commonjs",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"export var foo;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"nonewarrows",children:(0,i.jsx)(s.code,{children:"noNewArrows"})}),"\n",(0,i.jsxs)(s.p,{children:["Assume that the code never tries to instantiate arrow functions using ",(0,i.jsx)(s.code,{children:"new"}),", which is disallowed according to the specification."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"NOTE:"})," This assumption defaults to ",(0,i.jsx)(s.code,{children:"true"}),". It will default to ",(0,i.jsx)(s.code,{children:"false"})," starting from Babel 8."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"noNewArrows","data-plugins":"transform-arrow-functions",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let getSum = (a, b) => {\n  return { sum: a + b }\n};\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"nouninitializedprivatefieldaccess",children:(0,i.jsx)(s.code,{children:"noUninitializedPrivateFieldAccess"})}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"History"}),(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Version"}),(0,i.jsx)(s.th,{children:"Changes"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"v7.24.0"}),(0,i.jsxs)(s.td,{children:["Added ",(0,i.jsx)(s.code,{children:"noUninitializedPrivateFieldAccess"})," assumption"]})]})})]})]}),"\n",(0,i.jsx)(s.p,{children:"Assume that code never attempts to access private fields on classes before they are initialized. For example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Foo {\n  x = this.#y; // #y is not initialized yet\n  #y = 2;\n}\n"})}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"noUninitializedPrivateFieldAccess","data-plugins":"transform-class-properties",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class MyClass {\n  static #id = 123;\n\n  method() {\n    return MyClass.#id;\n  }\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"objectrestnosymbols",children:(0,i.jsx)(s.code,{children:"objectRestNoSymbols"})}),"\n",(0,i.jsx)(s.p,{children:"When using rest patterns in object destructuring, assume that destructured objects don't have symbol keys or that it's not a problem if they are not copied."}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"objectRestNoSymbols","data-plugins":"transform-destructuring,proposal-object-rest-spread",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let { name, ...attrs } = obj;\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"privatefieldsasproperties",children:(0,i.jsx)(s.code,{children:"privateFieldsAsProperties"})}),"\n",(0,i.jsxs)(s.p,{children:['Assume that "soft privacy" is enough for private fields, and thus they can be stored as public non-enumerable properties with an unique name (rather than using an external ',(0,i.jsx)(s.code,{children:"WeakMap"}),"). This makes debugging compiled private fields easier."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"privateFieldsAsProperties","data-plugins":"proposal-class-properties,proposal-private-methods",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Foo {\n  #method() {}\n\n  #field = 2;\n\n  run() {\n    this.#method();\n    this.#field++;\n  }\n}\n"})})}),"\n",(0,i.jsx)(s.admonition,{type:"caution",children:(0,i.jsx)(s.p,{children:"When using inline Babel helpers, generated string keys are unique per-file and not globally. This could cause conflicts when extending classes from a different fields with private fields with the same name."})}),"\n",(0,i.jsx)(s.h2,{id:"privatefieldsassymbols",children:(0,i.jsx)(s.code,{children:"privateFieldsAsSymbols"})}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"History"}),(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Version"}),(0,i.jsx)(s.th,{children:"Changes"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"v7.21.0"}),(0,i.jsxs)(s.td,{children:["Added ",(0,i.jsx)(s.code,{children:"privateFieldsAsSymbols"})," assumption"]})]})})]})]}),"\n",(0,i.jsxs)(s.p,{children:['Assume that "soft privacy" is enough for private fields, and thus they can be stored as public properties with a symbol key (rather than using an external ',(0,i.jsx)(s.code,{children:"WeakMap"}),"). This makes debugging compiled private fields easier."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"privateFieldsAsSymbols","data-plugins":"proposal-class-properties,proposal-private-methods",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",metastring:"assumption-input",children:"class Foo {\n  #method() {}\n\n  #field = 2;\n\n  run() {\n    this.#method();\n    this.#field++;\n  }\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"puregetters",children:(0,i.jsx)(s.code,{children:"pureGetters"})}),"\n",(0,i.jsx)(s.p,{children:"Assume that getters, if present, don't have side-effects and can be accessed multiple times."}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"pureGetters","data-plugins":"proposal-optional-chaining",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let a = obj;\n\na.b?.();\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"setclassmethods",children:(0,i.jsx)(s.code,{children:"setClassMethods"})}),"\n",(0,i.jsxs)(s.p,{children:["When declaring classes, assume that methods don't shadow accessors or non-writable properties on the superclass prototype, and that the program doesn't depend on methods being non-enumerable. Thus, it's safe to assign methods rather than using ",(0,i.jsx)(s.code,{children:"Object.defineProperty"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"setClassMethods","data-plugins":"transform-classes",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Foo extends Bar {\n  method() {}\n\n  static check() {}\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"setcomputedproperties",children:(0,i.jsx)(s.code,{children:"setComputedProperties"})}),"\n",(0,i.jsxs)(s.p,{children:["When using computed object properties, assume that the object doesn't contain properties that overwrite setter defined in the same object, and thus it's safe to assign them rather than defining them using ",(0,i.jsx)(s.code,{children:"Object.defineProperty"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"setComputedProperties","data-plugins":"transform-computed-properties",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"let obj = {\n  set name(value) {},\n  [key]: val\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"setpublicclassfields",children:(0,i.jsx)(s.code,{children:"setPublicClassFields"})}),"\n",(0,i.jsxs)(s.p,{children:["When using public class fields, assume that they don't shadow any getter in the current class, in its subclasses or in its superclass. Thus, it's safe to assign them rather than using ",(0,i.jsx)(s.code,{children:"Object.defineProperty"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"setPublicClassFields","data-plugins":"proposal-class-properties",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Test {\n  field = 2;\n\n  static staticField = 3;\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"setspreadproperties",children:(0,i.jsx)(s.code,{children:"setSpreadProperties"})}),"\n",(0,i.jsxs)(s.p,{children:["When using object spread, assume that spreaded properties don't trigger getters on the target object and thus it's safe to assign them rather than defining them using ",(0,i.jsx)(s.code,{children:"Object.defineProperty"}),"."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"setSpreadProperties","data-plugins":"proposal-object-rest-spread",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"const result = {\n  set name(value) {},\n  ...obj,\n};\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"skipforofiteratorclosing",children:(0,i.jsx)(s.code,{children:"skipForOfIteratorClosing"})}),"\n",(0,i.jsxs)(s.p,{children:["When using ",(0,i.jsx)(s.code,{children:"for-of"})," with an iterator, it should always be closed with ",(0,i.jsx)(s.code,{children:".return()"})," and with ",(0,i.jsx)(s.code,{children:".throw()"})," in case of an error. When this option is called Babel assumes that those methods are not defined or empty, and it avoids calling them."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"skipForOfIteratorClosing","data-plugins":"transform-for-of",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"for (const val of iterable) {\n  console.log(val);\n}\n"})})}),"\n",(0,i.jsx)(s.h2,{id:"superiscallableconstructor",children:(0,i.jsx)(s.code,{children:"superIsCallableConstructor"})}),"\n",(0,i.jsxs)(s.p,{children:["When extending classes, assume that the super class is callable. This means that it won't be possible to extend native classes or built-ins, but only compiled classes or ES5 ",(0,i.jsx)(s.code,{children:"function"})," constructors."]}),"\n",(0,i.jsx)("div",{is:"assumption-repl","data-assumption":"superIsCallableConstructor","data-plugins":"transform-classes",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="JavaScript"',children:"class Child extends Parent {\n  constructor() {\n    super(42);\n  }\n}\n"})})}),"\n",(0,i.jsxs)(s.h2,{id:"migrating-from-babelpreset-envs-loose-and-spec-modes",children:["Migrating from ",(0,i.jsx)(s.code,{children:"@babel/preset-env"}),"'s ",(0,i.jsx)(s.code,{children:'"loose"'})," and ",(0,i.jsx)(s.code,{children:'"spec"'})," modes"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"@babel/preset-env"}),"'s ",(0,i.jsx)(s.code,{children:"loose"})," option is equivalent to the following configuration:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",metastring:'title="JSON"',children:'{\n  "presets": [\n    ["@babel/preset-env", { "exclude": ["transform-typeof-symbol"] }]\n  ],\n  "assumptions": {\n    "arrayLikeIsIterable": true,\n    "constantReexports": true,\n    "ignoreFunctionLength": true,\n    "ignoreToPrimitiveHint": true,\n    "mutableTemplateObject": true,\n    "noClassCalls": true,\n    "noDocumentAll": true,\n    "objectRestNoSymbols": true,\n    "privateFieldsAsProperties": true,\n    "pureGetters": true,\n    "setClassMethods": true,\n    "setComputedProperties": true,\n    "setPublicClassFields": true,\n    "setSpreadProperties": true,\n    "skipForOfIteratorClosing": true,\n    "superIsCallableConstructor": true\n  }\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"@babel/preset-env"}),"'s ",(0,i.jsx)(s.code,{children:"spec"})," option is equivalent to the following configuration:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",metastring:'title="JSON"',children:'{\n  "presets": ["@babel/preset-env"],\n  "assumptions": {\n    "noNewArrows": false,\n  }\n}\n'})})]})}function p(e={}){let{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},50065:function(e,s,t){t.d(s,{Z:function(){return o},a:function(){return r}});var n=t(67294);let i={},a=n.createContext(i);function r(e){let s=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);