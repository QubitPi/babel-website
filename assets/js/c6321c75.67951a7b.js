"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5695],{35318:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return h}});var n=a(27378);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(a),b=r,h=u["".concat(l,".").concat(b)]||u[b]||m[b]||s;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=b;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}b.displayName="MDXCreateElement"},14696:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return u}});var n=a(25773),r=a(30808),s=(a(27378),a(35318)),o=["components"],i={layout:"post",title:"7.12.0 Released: TypeScript 4.1, strings as import/export names, and class static blocks",author:"Nicol\xf2 Ribaudo",authorURL:"https://twitter.com/NicoloRibaudo",date:new Date("2020-10-12T00:00:00.000Z"),categories:"announcements",share_text:"Babel 7.12.0 Released"},l=void 0,p={permalink:"/babel-website/blog/2020/10/15/7.12.0",source:"@site/blog/2020-10-15-7.12.0.md",title:"7.12.0 Released: TypeScript 4.1, strings as import/export names, and class static blocks",description:"We just published a new minor version of Babel!",date:"2020-10-12T00:00:00.000Z",formattedDate:"October 12, 2020",tags:[],readingTime:3.945,hasTruncateMarker:!0,authors:[{name:"Nicol\xf2 Ribaudo",url:"https://twitter.com/NicoloRibaudo"}],frontMatter:{layout:"post",title:"7.12.0 Released: TypeScript 4.1, strings as import/export names, and class static blocks",author:"Nicol\xf2 Ribaudo",authorURL:"https://twitter.com/NicoloRibaudo",date:"2020-10-12T00:00:00.000Z",categories:"announcements",share_text:"Babel 7.12.0 Released"},prevItem:{title:"7.13.0 Released: Records and Tuples, granular compiler assumptions, and top-level targets",permalink:"/babel-website/blog/2021/02/22/7.13.0"},nextItem:{title:"7.11.0 Released: ECMAScript 2021 support in preset-env, TypeScript 4.0 support, printing config and the future of `babel-eslint`",permalink:"/babel-website/blog/2020/07/30/7.11.0"}},c={authorsImageUrls:[void 0]},u=[{value:"Highlights",id:"highlights",level:2},{value:"TypeScript 4.1 (#12129, #12131)",id:"typescript-41-12129-12131",level:3},{value:"Class static blocks (#12079, #12143)",id:"class-static-blocks-12079-12143",level:3},{value:"Imports and exports with string names (#12091)",id:"imports-and-exports-with-string-names-12091",level:3},{value:"Import assertions parsing (#12139)",id:"import-assertions-parsing-12139",level:2}],m={toc:u},b="wrapper";function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,s.kt)(b,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"We just published a new minor version of Babel!"),(0,s.kt)("p",null,"This release includes support for the new TypeScript 4.1 beta features: ",(0,s.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types"},"template literal types")," and ",(0,s.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#key-remapping-mapped-types"},"key remapping in mapped types"),"."),(0,s.kt)("p",null,"Additionally, we implemented two new ECMAScript proposals: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-class-static-block"},"class static blocks")," and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/ecma262/pull/2154"},"imports and exports with string names"),"."),(0,s.kt)("p",null,"Lastly, we renamed ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-syntax-module-attributes")," (and the corresponding parser plugin ",(0,s.kt)("inlineCode",{parentName:"p"},"moduleAttributes"),") to ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-syntax-import-assertions")," (and ",(0,s.kt)("inlineCode",{parentName:"p"},"importAssertions"),"), to match the recent ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-import-assertions"},"proposal")," updates. The old plugin will work until Babel 8, but it's deprecated now."),(0,s.kt)("p",null,"You can read the whole changelog ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/babel/babel/releases/tag/v7.12.0"},"on GitHub"),"."),(0,s.kt)("p",null,"If you or your company want to support Babel and the evolution of JavaScript, but aren't sure how, you can donate to us on our ",(0,s.kt)("a",{parentName:"p",href:"https://opencollective.com/babel"},"Open Collective")," and, better yet, work with us on the implementation of ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/babel/proposals"},"new ECMAScript proposals")," directly! As a volunteer-driven project, we rely on the community's support to fund our efforts in supporting the wide range of JavaScript users. Reach out at ",(0,s.kt)("a",{parentName:"p",href:"mailto:team@babeljs.io"},"team@babeljs.io")," if you'd like to discuss more!"),(0,s.kt)("h2",{id:"highlights"},"Highlights"),(0,s.kt)("h3",{id:"typescript-41-12129-12131"},"TypeScript 4.1 (",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/babel/babel/pull/12129"},"#12129"),", ",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/babel/babel/pull/12131"},"#12131"),")"),(0,s.kt)("p",null,"TypeScript 4.1 beta ",(0,s.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#key-remapping-mapped-types"},"was announced")," a few weeks ago, and it includes new syntax features for types."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Template literal types")," allow concatenating strings at the type-level, using the template literal syntax:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'type Events = "Click" | "Focus";\n\ntype Handler = {\n  [K in `on${Events}`]: Function\n};\n\nconst handler: Handler = {\n    onClick() {}, // Ok\n    onFocus() {}, // Ok\n    onHover() {}, // Error!\n};\n')),(0,s.kt)("p",null,"Together with ",(0,s.kt)("strong",{parentName:"p"},"key remapping in mapped types"),", they can be used to represent complex object transformations:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"type Getters<T> = {\n    [K in keyof T as `get${Capitalize<K>}`]: () => T[K]\n};\n\ninterface Dog { name: string; age: number; }\n\nconst lazyDog: Getters<Dog> = /* ... */;\nlazyDog.getName(); // string\nlazyDog.age; // error!\n")),(0,s.kt)("p",null,"You can read more about TypeScript 4.1 in the ",(0,s.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/"},"release announcement"),", or check ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ghoullier/awesome-template-literal-types"},"other examples")," of what capabilities these new features unlock. However, remember that TypeScript 4.1 is still experimental!"),(0,s.kt)("h3",{id:"class-static-blocks-12079-12143"},"Class static blocks (",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/babel/babel/pull/12079"},"#12079"),", ",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/babel/babel/pull/12143"},"#12143"),")"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("a",{parentName:"p",href:"https://babel.dev/repl/build/29530/#?browsers=&build=&builtIns=false&spec=false&loose=true&code_lz=MYGwhgzhAEDC0G8BQ1oQC5nQS2NAHtALzQAsATANwpqY54Ce1qGWuiNq6ATgx6gOjoAFtggA6PiQAmAewDKsgLYBTEdgB2AcwDq2EQAp1E_AEpmAgL6dowLMGH9BQ0RKnQARAFcNAaw2yAO4aHhao1uFIlkA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=stage-2%2Ctypescript&prettier=true&targets=&version=7.11.6%2Bpr.12143&externalPlugins="},"Example on Babel REPL"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'class C {\n  static #x = 42;\n  static y;\n  static {\n    try {\n      this.y = doSomethingWith(this.#x);\n    } catch {\n      this.y = "unknown";\n    }\n  }\n}\n')),(0,s.kt)("p",null,"This stage 2 proposal allows you to apply additional static initializations when a class definition is evaluated. It is not intended to replace static fields but to enable new use cases that could not be accomplished before. In the example above, the static property ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," is initialized using ",(0,s.kt)("inlineCode",{parentName:"p"},"#x"),". If ",(0,s.kt)("inlineCode",{parentName:"p"},"doSomethingWith(this.#x)")," throws, ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," will be assigned by a default value ",(0,s.kt)("inlineCode",{parentName:"p"},'"unknown"'),"."),(0,s.kt)("p",null,"You can read more about it in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-class-static-block/blob/master/README.md"},"proposal's description"),"."),(0,s.kt)("p",null,"Thanks to ",(0,s.kt)("a",{parentName:"p",href:"https://twitter.com/JLHwung"},"J\xf9nli\xe0ng"),", you can test this proposal by installing\nthe ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-proposal-class-static-block")," plugin and adding it to your Babel config. Since it is likely you're already using other class feature plugins, be sure to place this plugin ",(0,s.kt)("em",{parentName:"p"},"before")," the others:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="babel.config.json"',title:'"babel.config.json"'},'{\n  "plugins": [\n    "@babel/plugin-proposal-class-static-block",\n    "@babel/plugin-proposal-class-properties"\n  ]\n}\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f Babel implements an ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-class-static-block/pull/15"},"updated")," version of spec, which addresses ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-class-static-block/issues?q=is%3Aissue+author%3AJLHwung+created%3A%3C2020-10-07"},"feedback")," we have provided based on the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-class-static-block/commit/1bfccb28a8174f6ca3f92242bd9589985190100c"},"current")," spec.")),(0,s.kt)("h3",{id:"imports-and-exports-with-string-names-12091"},"Imports and exports with string names (",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/babel/babel/pull/12091"},"#12091"),")"),(0,s.kt)("p",null,"Consensus was achieved during the last TC39 meeting with ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/ecma262/pull/2154"},"a PR")," to allow strings as the name of imported and exported variables:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'// emojis.js\nlet happy = "wooo!";\nexport { happy as "\ud83d\ude03" };\n\n// main.js\nimport { "\ud83d\ude03" as smile } from "./emojis.js";\nconsole.log(smile); // wooo!\n')),(0,s.kt)("p",null,"This allows using any valid UTF-16 name across modules, making JavaScript fully compatible with other languages such as WebAssembly."),(0,s.kt)("p",null,"You can enable ",(0,s.kt)("em",{parentName:"p"},"parsing")," support for this feature by adding ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-syntax-module-string-names")," to your configuration:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="babel.config.json"',title:'"babel.config.json"'},'{\n  "presets:" ["@babel/preset-env"],\n  "plugins": [\n    "@babel/syntax-module-string-names"\n  ]\n}\n')),(0,s.kt)("p",null,"This feature will be enabled by ",(0,s.kt)("em",{parentName:"p"},"default")," as soon as the syntax is merged into the main ECMAScript specification."),(0,s.kt)("p",null,"Please note that it's not possible to transpile arbitrary strings to ES2015-style imports and exports: they will only be transpiled when targeting a different modules system such as CommonJS."),(0,s.kt)("h2",{id:"import-assertions-parsing-12139"},"Import assertions parsing (",(0,s.kt)("a",{parentName:"h2",href:"https://github.com/babel/babel/pull/12139"},"#12139"),")"),(0,s.kt)("p",null,'The "module attributes" proposal has been significantly changed and also renamed to "import assertions".'),(0,s.kt)("p",null,"We've implemented parsing support for this new version of the proposal, which can be enabled using the ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-syntax-import-assertions")," plugin (or, if you are directly using ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/parser"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"importAssertions"),"):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},' {\n   "plugins": [\n-    ["@babel/syntax-module-attributes", { "version": "may-2020" }]\n+    "@babel/syntax-import-assertions"\n   ]\n }\n')),(0,s.kt)("p",null,"The most significant syntax changes are that the ",(0,s.kt)("inlineCode",{parentName:"p"},"with")," keyword has been replaced with ",(0,s.kt)("inlineCode",{parentName:"p"},"assert")," and assertions are now wrapped in curly braces:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="JavaScript"',title:'"JavaScript"'},'import json from "./foo.json" assert { type: "json" };\n\nimport("foo.json", { assert: { type: "json" } });\n')),(0,s.kt)("p",null,"You can read more about these changes in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-import-assertions#readme"},"proposal's README"),"."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f ",(0,s.kt)("inlineCode",{parentName:"p"},"@babel/plugin-syntax-module-attributes")," will continue working until we release Babel 8.0.0, but will no longer be maintained, so we highly recommended migrating to the new plugin.")))}h.isMDXComponent=!0}}]);